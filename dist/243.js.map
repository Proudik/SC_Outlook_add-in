{"version":3,"file":"243.js","mappings":"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","sources":["webpack://office-addin-taskpane-react/./src/utils/filedCache.ts"],"sourcesContent":["import { getStored, setStored } from \"./storage\";\n\nconst FILED_CACHE_KEY = \"sc:filedEmailsCache\";\n\nexport type FiledEmailCache = {\n  [conversationId: string]: {\n    caseId: string;\n    documentId: string;\n    subject: string;\n    caseName?: string;\n    caseKey?: string;\n    filedAt: number; // timestamp\n  };\n};\n\n/**\n * Store filed email info by conversationId\n * This enables \"already filed\" detection for self-sent emails and replies\n *\n * Works for:\n * - Self-sent emails (sender opens received copy)\n * - Sent items (user reopens their own sent email)\n * - Replies in same thread (same conversationId)\n */\nexport async function cacheFiledEmail(\n  conversationId: string,\n  caseId: string,\n  documentId: string,\n  subject: string,\n  caseName?: string,\n  caseKey?: string\n): Promise<void> {\n  if (!conversationId) {\n    console.warn(\"[cacheFiledEmail] No conversationId provided, skipping cache\");\n    return;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[cacheFiledEmail] Platform info:\", platform);\n\n    const raw = await getStored(FILED_CACHE_KEY);\n    const cache: FiledEmailCache = raw ? JSON.parse(String(raw)) : {};\n    console.log(\"[cacheFiledEmail] Current cache size:\", Object.keys(cache).length);\n\n    cache[conversationId] = {\n      caseId,\n      documentId,\n      subject,\n      caseName,\n      caseKey,\n      filedAt: Date.now(),\n    };\n\n    // Clean old entries (keep last 100 filed emails)\n    const entries = Object.entries(cache);\n    if (entries.length > 100) {\n      entries.sort((a, b) => b[1].filedAt - a[1].filedAt);\n      const keep = entries.slice(0, 100);\n      const newCache: FiledEmailCache = {};\n      keep.forEach(([key, val]) => {\n        newCache[key] = val;\n      });\n      await setStored(FILED_CACHE_KEY, JSON.stringify(newCache));\n      console.log(\"[cacheFiledEmail] Cleaned cache, kept 100 most recent entries\");\n    } else {\n      await setStored(FILED_CACHE_KEY, JSON.stringify(cache));\n    }\n\n    // Verify write succeeded\n    const verification = await getStored(FILED_CACHE_KEY);\n    const verifiedCache = verification ? JSON.parse(String(verification)) : {};\n    const writeSuccess = !!verifiedCache[conversationId];\n    console.log(\"[cacheFiledEmail] Write verification:\", {\n      success: writeSuccess,\n      cacheSize: Object.keys(verifiedCache).length,\n    });\n\n    console.log(\"[cacheFiledEmail] Cached filed email\", {\n      conversationId: conversationId.substring(0, 20) + \"...\",\n      caseId,\n      documentId,\n      subject,\n      writeVerified: writeSuccess,\n    });\n  } catch (e) {\n    console.warn(\"[cacheFiledEmail] Failed to cache:\", e);\n    // Non-critical, don't throw\n  }\n}\n\n/**\n * Check if email with this conversationId was filed\n * Returns cached info if found, null otherwise\n */\nexport async function getFiledEmailFromCache(\n  conversationId: string\n): Promise<FiledEmailCache[string] | null> {\n  if (!conversationId) {\n    return null;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[getFiledEmailFromCache] Platform info:\", platform);\n\n    // Force fresh read to avoid stale roamingSettings after recent write\n    const raw = await getStored(FILED_CACHE_KEY, true);\n    if (!raw) {\n      console.log(\"[getFiledEmailFromCache] No cache found in storage\");\n      return null;\n    }\n\n    const cache: FiledEmailCache = JSON.parse(String(raw));\n    const cacheKeys = Object.keys(cache);\n    console.log(\"[getFiledEmailFromCache] Cache size:\", cacheKeys.length, \"keys\");\n    console.log(\"[getFiledEmailFromCache] Looking for conversationId:\", conversationId.substring(0, 30) + \"...\");\n    console.log(\"[getFiledEmailFromCache] Sample cache keys:\", cacheKeys.slice(0, 3).map(k => k.substring(0, 30) + \"...\"));\n\n    const entry = cache[conversationId];\n\n    if (entry) {\n      console.log(\"[getFiledEmailFromCache] ✅ Found cache entry\", {\n        conversationId: conversationId.substring(0, 20) + \"...\",\n        caseId: entry.caseId,\n        documentId: entry.documentId,\n        filedAt: new Date(entry.filedAt).toISOString(),\n        subject: entry.subject,\n      });\n      return entry;\n    }\n\n    console.log(\"[getFiledEmailFromCache] ❌ No entry for this conversationId\");\n    return null;\n  } catch (e) {\n    console.warn(\"[getFiledEmailFromCache] Failed to read cache:\", e);\n    return null;\n  }\n}\n\n/**\n * Cache filed email by subject (fallback when conversationId not available at send time)\n * Used for NEW compose emails where conversationId isn't assigned until after send\n */\nexport async function cacheFiledEmailBySubject(\n  subject: string,\n  caseId: string,\n  documentId: string,\n  caseName?: string,\n  caseKey?: string\n): Promise<void> {\n  if (!subject) {\n    console.warn(\"[cacheFiledEmailBySubject] No subject provided, skipping cache\");\n    return;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[cacheFiledEmailBySubject] Platform info:\", platform);\n\n    const raw = await getStored(FILED_CACHE_KEY);\n    const cache: FiledEmailCache = raw ? JSON.parse(String(raw)) : {};\n    console.log(\"[cacheFiledEmailBySubject] Current cache size:\", Object.keys(cache).length);\n\n    // Use subject as temporary key (prefixed with \"subj:\")\n    const tempKey = `subj:${subject.trim().toLowerCase()}`;\n    console.log(\"[cacheFiledEmailBySubject] Using temp key:\", tempKey);\n\n    cache[tempKey] = {\n      caseId,\n      documentId,\n      subject,\n      caseName,\n      caseKey,\n      filedAt: Date.now(),\n    };\n\n    // Clean old entries\n    const entries = Object.entries(cache);\n    if (entries.length > 100) {\n      entries.sort((a, b) => b[1].filedAt - a[1].filedAt);\n      const keep = entries.slice(0, 100);\n      const newCache: FiledEmailCache = {};\n      keep.forEach(([key, val]) => {\n        newCache[key] = val;\n      });\n      await setStored(FILED_CACHE_KEY, JSON.stringify(newCache));\n      console.log(\"[cacheFiledEmailBySubject] Cleaned cache, kept 100 most recent entries\");\n    } else {\n      await setStored(FILED_CACHE_KEY, JSON.stringify(cache));\n    }\n\n    // Verify write succeeded\n    const verification = await getStored(FILED_CACHE_KEY);\n    const verifiedCache = verification ? JSON.parse(String(verification)) : {};\n    const writeSuccess = !!verifiedCache[tempKey];\n    console.log(\"[cacheFiledEmailBySubject] Write verification:\", {\n      success: writeSuccess,\n      cacheSize: Object.keys(verifiedCache).length,\n      tempKey,\n    });\n\n    console.log(\"[cacheFiledEmailBySubject] Cached filed email by subject\", {\n      subject,\n      caseId,\n      documentId,\n      writeVerified: writeSuccess,\n    });\n  } catch (e) {\n    console.warn(\"[cacheFiledEmailBySubject] Failed to cache:\", e);\n  }\n}\n\n/**\n * Search cache by subject (fallback when conversationId lookup fails)\n * Also upgrades the cache entry to use conversationId for future lookups\n */\nexport async function findFiledEmailBySubject(\n  subject: string,\n  conversationId?: string\n): Promise<FiledEmailCache[string] | null> {\n  if (!subject) {\n    return null;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[findFiledEmailBySubject] Platform info:\", platform);\n\n    // Force fresh read to avoid stale roamingSettings after recent write\n    const raw = await getStored(FILED_CACHE_KEY, true);\n    if (!raw) {\n      console.log(\"[findFiledEmailBySubject] No cache found in storage\");\n      return null;\n    }\n\n    const cache: FiledEmailCache = JSON.parse(String(raw));\n    const cacheKeys = Object.keys(cache);\n    console.log(\"[findFiledEmailBySubject] Cache size:\", cacheKeys.length, \"keys\");\n\n    const tempKey = `subj:${subject.trim().toLowerCase()}`;\n    console.log(\"[findFiledEmailBySubject] Looking for temp key:\", tempKey);\n    console.log(\"[findFiledEmailBySubject] Subject-based keys in cache:\", cacheKeys.filter(k => k.startsWith(\"subj:\")).length);\n\n    const entry = cache[tempKey];\n\n    if (entry) {\n      console.log(\"[findFiledEmailBySubject] ✅ Found cache entry by subject\", {\n        subject,\n        caseId: entry.caseId,\n        documentId: entry.documentId,\n        filedAt: new Date(entry.filedAt).toISOString(),\n      });\n\n      // Upgrade cache: If we now have conversationId, store under that key too\n      if (conversationId) {\n        console.log(\"[findFiledEmailBySubject] Upgrading cache with conversationId:\", conversationId.substring(0, 30) + \"...\");\n        cache[conversationId] = entry;\n        // Keep the subject-based entry for a while (don't delete)\n        await setStored(FILED_CACHE_KEY, JSON.stringify(cache));\n\n        // Verify upgrade succeeded\n        const verification = await getStored(FILED_CACHE_KEY);\n        const verifiedCache = verification ? JSON.parse(String(verification)) : {};\n        const upgradeSuccess = !!verifiedCache[conversationId];\n        console.log(\"[findFiledEmailBySubject] Cache upgrade verification:\", {\n          success: upgradeSuccess,\n          cacheSize: Object.keys(verifiedCache).length,\n        });\n      }\n\n      return entry;\n    }\n\n    console.log(\"[findFiledEmailBySubject] ❌ No entry for this subject\");\n    return null;\n  } catch (e) {\n    console.warn(\"[findFiledEmailBySubject] Failed:\", e);\n    return null;\n  }\n}\n\n/**\n * Remove filed email from cache (e.g., if document was deleted)\n */\nexport async function removeFiledEmailFromCache(conversationId: string): Promise<void> {\n  if (!conversationId) {\n    return;\n  }\n\n  try {\n    const raw = await getStored(FILED_CACHE_KEY);\n    if (!raw) return;\n\n    const cache: FiledEmailCache = JSON.parse(String(raw));\n    delete cache[conversationId];\n\n    await setStored(FILED_CACHE_KEY, JSON.stringify(cache));\n    console.log(\"[removeFiledEmailFromCache] Removed entry\", {\n      conversationId: conversationId.substring(0, 20) + \"...\",\n    });\n  } catch (e) {\n    console.warn(\"[removeFiledEmailFromCache] Failed:\", e);\n  }\n}\n"],"names":["FILED_CACHE_KEY","cacheFiledEmail","conversationId","caseId","documentId","subject","caseName","caseKey","console","warn","platform","host","_c","_b","_a","Office","context","mailbox","diagnostics","hostName","hostVersion","_f","_e","_d","_g","log","getStored","raw","_h","sent","cache","JSON","parse","String","Object","keys","length","filedAt","Date","now","entries","sort","a","b","keep","slice","newCache_1","forEach","key","val","setStored","stringify","verification","verifiedCache","writeSuccess","success","cacheSize","substring","writeVerified","e_1","getFiledEmailFromCache","cacheKeys","map","k","entry","toISOString","e_2","cacheFiledEmailBySubject","tempKey","concat","trim","toLowerCase","newCache_2","e_3","findFiledEmailBySubject","filter","startsWith","upgradeSuccess","e_4","removeFiledEmailFromCache","e_5"],"ignoreList":[],"sourceRoot":""}