{"version":3,"file":"commands.js","mappings":"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","sources":["webpack://office-addin-taskpane-react/./node_modules/es6-promise/dist/es6-promise.js","webpack://office-addin-taskpane-react/webpack/bootstrap","webpack://office-addin-taskpane-react/webpack/runtime/global","webpack://office-addin-taskpane-react/./src/services/auth.ts","webpack://office-addin-taskpane-react/./src/utils/storage.ts","webpack://office-addin-taskpane-react/./src/utils/constants.ts","webpack://office-addin-taskpane-react/./src/services/singlecaseDocuments.ts","webpack://office-addin-taskpane-react/./src/utils/filedCache.ts","webpack://office-addin-taskpane-react/./src/commands/onMessageSendHandler.ts","webpack://office-addin-taskpane-react/./src/commands/commands.ts"],"sourcesContent":["/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ES6Promise = factory());\n}(this, (function () { 'use strict';\n\nfunction objectOrFunction(x) {\n  var type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\n\n\nvar _isArray = void 0;\nif (Array.isArray) {\n  _isArray = Array.isArray;\n} else {\n  _isArray = function (x) {\n    return Object.prototype.toString.call(x) === '[object Array]';\n  };\n}\n\nvar isArray = _isArray;\n\nvar len = 0;\nvar vertxNext = void 0;\nvar customSchedulerFn = void 0;\n\nvar asap = function asap(callback, arg) {\n  queue[len] = callback;\n  queue[len + 1] = arg;\n  len += 2;\n  if (len === 2) {\n    // If len is 2, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    if (customSchedulerFn) {\n      customSchedulerFn(flush);\n    } else {\n      scheduleFlush();\n    }\n  }\n};\n\nfunction setScheduler(scheduleFn) {\n  customSchedulerFn = scheduleFn;\n}\n\nfunction setAsap(asapFn) {\n  asap = asapFn;\n}\n\nvar browserWindow = typeof window !== 'undefined' ? window : undefined;\nvar browserGlobal = browserWindow || {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n// test for web worker but not in IE10\nvar isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n// node\nfunction useNextTick() {\n  // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n  // see https://github.com/cujojs/when/issues/410 for details\n  return function () {\n    return process.nextTick(flush);\n  };\n}\n\n// vertx\nfunction useVertxTimer() {\n  if (typeof vertxNext !== 'undefined') {\n    return function () {\n      vertxNext(flush);\n    };\n  }\n\n  return useSetTimeout();\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function () {\n    node.data = iterations = ++iterations % 2;\n  };\n}\n\n// web worker\nfunction useMessageChannel() {\n  var channel = new MessageChannel();\n  channel.port1.onmessage = flush;\n  return function () {\n    return channel.port2.postMessage(0);\n  };\n}\n\nfunction useSetTimeout() {\n  // Store setTimeout reference so es6-promise will be unaffected by\n  // other code modifying setTimeout (like sinon.useFakeTimers())\n  var globalSetTimeout = setTimeout;\n  return function () {\n    return globalSetTimeout(flush, 1);\n  };\n}\n\nvar queue = new Array(1000);\nfunction flush() {\n  for (var i = 0; i < len; i += 2) {\n    var callback = queue[i];\n    var arg = queue[i + 1];\n\n    callback(arg);\n\n    queue[i] = undefined;\n    queue[i + 1] = undefined;\n  }\n\n  len = 0;\n}\n\nfunction attemptVertx() {\n  try {\n    var vertx = Function('return this')().require('vertx');\n    vertxNext = vertx.runOnLoop || vertx.runOnContext;\n    return useVertxTimer();\n  } catch (e) {\n    return useSetTimeout();\n  }\n}\n\nvar scheduleFlush = void 0;\n// Decide what async method to use to triggering processing of queued callbacks:\nif (isNode) {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else if (isWorker) {\n  scheduleFlush = useMessageChannel();\n} else if (browserWindow === undefined && typeof require === 'function') {\n  scheduleFlush = attemptVertx();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction then(onFulfillment, onRejection) {\n  var parent = this;\n\n  var child = new this.constructor(noop);\n\n  if (child[PROMISE_ID] === undefined) {\n    makePromise(child);\n  }\n\n  var _state = parent._state;\n\n\n  if (_state) {\n    var callback = arguments[_state - 1];\n    asap(function () {\n      return invokeCallback(_state, child, callback, parent._result);\n    });\n  } else {\n    subscribe(parent, child, onFulfillment, onRejection);\n  }\n\n  return child;\n}\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nfunction resolve$1(object) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  var promise = new Constructor(noop);\n  resolve(promise, object);\n  return promise;\n}\n\nvar PROMISE_ID = Math.random().toString(36).substring(2);\n\nfunction noop() {}\n\nvar PENDING = void 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\n\nfunction selfFulfillment() {\n  return new TypeError(\"You cannot resolve a promise with itself\");\n}\n\nfunction cannotReturnOwn() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n  try {\n    then$$1.call(value, fulfillmentHandler, rejectionHandler);\n  } catch (e) {\n    return e;\n  }\n}\n\nfunction handleForeignThenable(promise, thenable, then$$1) {\n  asap(function (promise) {\n    var sealed = false;\n    var error = tryThen(then$$1, thenable, function (value) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n      if (thenable !== value) {\n        resolve(promise, value);\n      } else {\n        fulfill(promise, value);\n      }\n    }, function (reason) {\n      if (sealed) {\n        return;\n      }\n      sealed = true;\n\n      reject(promise, reason);\n    }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n    if (!sealed && error) {\n      sealed = true;\n      reject(promise, error);\n    }\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, function (value) {\n      return resolve(promise, value);\n    }, function (reason) {\n      return reject(promise, reason);\n    });\n  }\n}\n\nfunction handleMaybeThenable(promise, maybeThenable, then$$1) {\n  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n    handleOwnThenable(promise, maybeThenable);\n  } else {\n    if (then$$1 === undefined) {\n      fulfill(promise, maybeThenable);\n    } else if (isFunction(then$$1)) {\n      handleForeignThenable(promise, maybeThenable, then$$1);\n    } else {\n      fulfill(promise, maybeThenable);\n    }\n  }\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    reject(promise, selfFulfillment());\n  } else if (objectOrFunction(value)) {\n    var then$$1 = void 0;\n    try {\n      then$$1 = value.then;\n    } catch (error) {\n      reject(promise, error);\n      return;\n    }\n    handleMaybeThenable(promise, value, then$$1);\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nfunction publishRejection(promise) {\n  if (promise._onerror) {\n    promise._onerror(promise._result);\n  }\n\n  publish(promise);\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length !== 0) {\n    asap(publish, promise);\n  }\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) {\n    return;\n  }\n  promise._state = REJECTED;\n  promise._result = reason;\n\n  asap(publishRejection, promise);\n}\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var _subscribers = parent._subscribers;\n  var length = _subscribers.length;\n\n\n  parent._onerror = null;\n\n  _subscribers[length] = child;\n  _subscribers[length + FULFILLED] = onFulfillment;\n  _subscribers[length + REJECTED] = onRejection;\n\n  if (length === 0 && parent._state) {\n    asap(publish, parent);\n  }\n}\n\nfunction publish(promise) {\n  var subscribers = promise._subscribers;\n  var settled = promise._state;\n\n  if (subscribers.length === 0) {\n    return;\n  }\n\n  var child = void 0,\n      callback = void 0,\n      detail = promise._result;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, detail);\n    } else {\n      callback(detail);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value = void 0,\n      error = void 0,\n      succeeded = true;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n    } catch (e) {\n      succeeded = false;\n      error = e;\n    }\n\n    if (promise === value) {\n      reject(promise, cannotReturnOwn());\n      return;\n    }\n  } else {\n    value = detail;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (succeeded === false) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    fulfill(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nfunction initializePromise(promise, resolver) {\n  try {\n    resolver(function resolvePromise(value) {\n      resolve(promise, value);\n    }, function rejectPromise(reason) {\n      reject(promise, reason);\n    });\n  } catch (e) {\n    reject(promise, e);\n  }\n}\n\nvar id = 0;\nfunction nextId() {\n  return id++;\n}\n\nfunction makePromise(promise) {\n  promise[PROMISE_ID] = id++;\n  promise._state = undefined;\n  promise._result = undefined;\n  promise._subscribers = [];\n}\n\nfunction validationError() {\n  return new Error('Array Methods must be provided an Array');\n}\n\nvar Enumerator = function () {\n  function Enumerator(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  Enumerator.prototype._enumerate = function _enumerate(input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n\n    if (resolve$$1 === resolve$1) {\n      var _then = void 0;\n      var error = void 0;\n      var didError = false;\n      try {\n        _then = entry.then;\n      } catch (e) {\n        didError = true;\n        error = e;\n      }\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$1) {\n        var promise = new c(noop);\n        if (didError) {\n          reject(promise, error);\n        } else {\n          handleMaybeThenable(promise, entry, _then);\n        }\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n    var promise = this.promise;\n\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  return Enumerator;\n}();\n\n/**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/\nfunction all(entries) {\n  return new Enumerator(this, entries).promise;\n}\n\n/**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/\nfunction race(entries) {\n  /*jshint validthis:true */\n  var Constructor = this;\n\n  if (!isArray(entries)) {\n    return new Constructor(function (_, reject) {\n      return reject(new TypeError('You must pass an array to race.'));\n    });\n  } else {\n    return new Constructor(function (resolve, reject) {\n      var length = entries.length;\n      for (var i = 0; i < length; i++) {\n        Constructor.resolve(entries[i]).then(resolve, reject);\n      }\n    });\n  }\n}\n\n/**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/\nfunction reject$1(reason) {\n  /*jshint validthis:true */\n  var Constructor = this;\n  var promise = new Constructor(noop);\n  reject(promise, reason);\n  return promise;\n}\n\nfunction needsResolver() {\n  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n}\n\nfunction needsNew() {\n  throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n}\n\n/**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/\n\nvar Promise$1 = function () {\n  function Promise(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */\n\n  /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */\n\n\n  Promise.prototype.catch = function _catch(onRejection) {\n    return this.then(null, onRejection);\n  };\n\n  /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */\n\n\n  Promise.prototype.finally = function _finally(callback) {\n    var promise = this;\n    var constructor = promise.constructor;\n\n    if (isFunction(callback)) {\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      });\n    }\n\n    return promise.then(callback, callback);\n  };\n\n  return Promise;\n}();\n\nPromise$1.prototype.then = then;\nPromise$1.all = all;\nPromise$1.race = race;\nPromise$1.resolve = resolve$1;\nPromise$1.reject = reject$1;\nPromise$1._setScheduler = setScheduler;\nPromise$1._setAsap = setAsap;\nPromise$1._asap = asap;\n\n/*global self*/\nfunction polyfill() {\n  var local = void 0;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n\n  var P = local.Promise;\n\n  if (P) {\n    var promiseToString = null;\n    try {\n      promiseToString = Object.prototype.toString.call(P.resolve());\n    } catch (e) {\n      // silently ignored\n    }\n\n    if (promiseToString === '[object Promise]' && !P.cast) {\n      return;\n    }\n  }\n\n  local.Promise = Promise$1;\n}\n\n// Strange compat..\nPromise$1.polyfill = polyfill;\nPromise$1.Promise = Promise$1;\n\nreturn Promise$1;\n\n})));\n\n\n\n//# sourceMappingURL=es6-promise.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","/* global OfficeRuntime */\n\nconst TOKEN_KEY = \"singlecase_token\";\nconst USER_KEY = \"singlecase_user_email\";\nconst ISSUED_AT_KEY = \"singlecase_auth_issued_at\";\n\n// Mirror keys into OfficeRuntime.storage so Commands runtime can read them\nconst RT_TOKEN_KEY = \"sc_token\";\nconst RT_USER_KEY = \"sc_user_email\";\nconst RT_ISSUED_AT_KEY = \"sc_auth_issued_at\";\n\n// Typical session TTL: 8 hours. Adjust as you like.\nconst SESSION_TTL_MS = 8 * 60 * 60 * 1000;\n\nfunction normalizeEmail(email: string | null | undefined): string {\n  const v = (email || \"\").trim().toLowerCase();\n  return v.length > 0 ? v : \"unknown@singlecase.local\";\n}\n\nasync function rtGet(key: string): Promise<string | null> {\n  // Try OfficeRuntime.storage first\n  if (typeof OfficeRuntime !== 'undefined' && (OfficeRuntime as any)?.storage) {\n    try {\n      const v = await (OfficeRuntime as any).storage.getItem(key);\n      if (typeof v === \"string\") return v;\n    } catch (e) {\n      console.warn(\"[rtGet] OfficeRuntime.storage.getItem failed:\", e);\n    }\n  }\n\n  // Fallback to Office.context.roamingSettings (Outlook-specific, works cross-context)\n  if ((Office as any)?.context?.roamingSettings) {\n    try {\n      const v = (Office as any).context.roamingSettings.get(key);\n      if (typeof v === \"string\") return v;\n    } catch (e) {\n      console.warn(\"[rtGet] roamingSettings.get failed:\", e);\n    }\n  }\n\n  return null;\n}\n\nasync function rtSet(key: string, value: string): Promise<void> {\n  // Try OfficeRuntime.storage first\n  if (typeof OfficeRuntime !== 'undefined' && (OfficeRuntime as any)?.storage) {\n    try {\n      await (OfficeRuntime as any).storage.setItem(key, value);\n      console.log(\"[rtSet] Saved to OfficeRuntime.storage:\", key);\n      return; // Success\n    } catch (e) {\n      console.warn(\"[rtSet] OfficeRuntime.storage.setItem failed:\", e);\n    }\n  }\n\n  // Fallback to Office.context.roamingSettings (Outlook-specific, works cross-context)\n  if ((Office as any)?.context?.roamingSettings) {\n    try {\n      (Office as any).context.roamingSettings.set(key, value);\n      await new Promise<void>((resolve, reject) => {\n        (Office as any).context.roamingSettings.saveAsync((result: any) => {\n          if (result.status === (Office as any).AsyncResultStatus.Succeeded) {\n            console.log(\"[rtSet] Saved to roamingSettings:\", key);\n            resolve();\n          } else {\n            console.error(\"[rtSet] roamingSettings.saveAsync failed:\", result.error);\n            reject(new Error(result.error?.message || \"saveAsync failed\"));\n          }\n        });\n      });\n    } catch (e) {\n      console.error(\"[rtSet] roamingSettings failed:\", e);\n    }\n  }\n}\n\nasync function rtRemove(key: string): Promise<void> {\n  try {\n    await (OfficeRuntime as any).storage.removeItem(key);\n  } catch {\n    // ignore\n  }\n}\n\nexport function getAuth(): { token: string | null; email: string; issuedAt: number } {\n  const token = sessionStorage.getItem(TOKEN_KEY);\n  const emailRaw = sessionStorage.getItem(USER_KEY);\n  const issuedAtStr = sessionStorage.getItem(ISSUED_AT_KEY);\n\n  return {\n    token,\n    email: normalizeEmail(emailRaw),\n    issuedAt: issuedAtStr ? Number(issuedAtStr) : 0,\n  };\n}\n\n// Async version for runtimes that cannot access sessionStorage (eg Commands)\nexport async function getAuthRuntime(): Promise<{ token: string | null; email: string; issuedAt: number }> {\n  const [token, emailRaw, issuedAtStr] = await Promise.all([\n    rtGet(RT_TOKEN_KEY),\n    rtGet(RT_USER_KEY),\n    rtGet(RT_ISSUED_AT_KEY),\n  ]);\n\n  return {\n    token,\n    email: normalizeEmail(emailRaw),\n    issuedAt: issuedAtStr ? Number(issuedAtStr) : 0,\n  };\n}\n\n// Make this async so you can await the mirror write when needed.\nexport async function setAuth(token: string, email: string): Promise<void> {\n  const emailNorm = normalizeEmail(email);\n  const issuedAt = Date.now();\n\n  sessionStorage.setItem(TOKEN_KEY, token);\n  sessionStorage.setItem(USER_KEY, emailNorm);\n  sessionStorage.setItem(ISSUED_AT_KEY, String(issuedAt));\n\n  // Mirror for command runtime\n  await Promise.all([\n    rtSet(RT_TOKEN_KEY, token),\n    rtSet(RT_USER_KEY, emailNorm),\n    rtSet(RT_ISSUED_AT_KEY, String(issuedAt)),\n  ]);\n}\n\nexport function clearAuthIfExpired(): void {\n  const { token, issuedAt } = getAuth();\n  if (!token) return;\n\n  const ageMs = Date.now() - (issuedAt || 0);\n  if (!issuedAt || ageMs > SESSION_TTL_MS) {\n    void clearAuth();\n  }\n}\n\nexport async function clearAuthIfExpiredRuntime(): Promise<void> {\n  const { token, issuedAt } = await getAuthRuntime();\n  if (!token) return;\n\n  const ageMs = Date.now() - (issuedAt || 0);\n  if (!issuedAt || ageMs > SESSION_TTL_MS) {\n    await clearAuth();\n  }\n}\n\nexport async function clearAuth(): Promise<void> {\n  sessionStorage.removeItem(TOKEN_KEY);\n  sessionStorage.removeItem(USER_KEY);\n  sessionStorage.removeItem(ISSUED_AT_KEY);\n\n  await Promise.all([rtRemove(RT_TOKEN_KEY), rtRemove(RT_USER_KEY), rtRemove(RT_ISSUED_AT_KEY)]);\n}\n\nexport function isLoggedIn(): boolean {\n  const { token, issuedAt } = getAuth();\n  if (!token) return false;\n\n  const ageMs = Date.now() - (issuedAt || 0);\n  return Boolean(issuedAt && ageMs <= SESSION_TTL_MS);\n}\n\nexport async function isLoggedInRuntime(): Promise<boolean> {\n  const { token, issuedAt } = await getAuthRuntime();\n  if (!token) return false;\n\n  const ageMs = Date.now() - (issuedAt || 0);\n  return Boolean(issuedAt && ageMs <= SESSION_TTL_MS);\n}","// src/utils/storage.ts\n/* global Office, OfficeRuntime */\n\n// Feature flag: Set to false to silence verbose logging (helps with render loops)\nconst VERBOSE_LOGGING = false;\n\n// Debug log that persists across sessions\nconst DEBUG_LOG_KEY = \"sc:debugLog\";\n\nexport async function getDebugLog(): Promise<string> {\n  try {\n    if (hasRoamingSettings()) {\n      return String(Office.context.roamingSettings.get(DEBUG_LOG_KEY) || \"\");\n    } else if (typeof localStorage !== \"undefined\") {\n      return localStorage.getItem(DEBUG_LOG_KEY) || \"\";\n    }\n    return \"\";\n  } catch {\n    return \"\";\n  }\n}\n\nexport async function clearDebugLog(): Promise<void> {\n  try {\n    if (hasRoamingSettings()) {\n      Office.context.roamingSettings.remove(DEBUG_LOG_KEY);\n      await saveRoamingSettings();\n    } else if (typeof localStorage !== \"undefined\") {\n      localStorage.removeItem(DEBUG_LOG_KEY);\n    }\n  } catch {\n    // Silent fail\n  }\n}\n\nfunction hasOfficeRuntimeStorage(): boolean {\n  try {\n    return typeof OfficeRuntime !== \"undefined\" && !!(OfficeRuntime as any)?.storage;\n  } catch {\n    return false;\n  }\n}\n\nfunction hasRoamingSettings(): boolean {\n  try {\n    return !!Office?.context?.roamingSettings;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Emergency in-memory pruning when roamingSettings hits the 32KB limit.\n * Removes old individual sc:sent:* / sc_conv_ctx:* keys (via internal _data access),\n * prunes the sentPills blob and the filed-email cache to 3 entries each.\n * Does NOT call saveAsync  caller must do that after this returns.\n */\nfunction emergencyPruneRoamingSettings(): void {\n  // 1. Remove debug log\n  try { Office.context.roamingSettings.remove(DEBUG_LOG_KEY); } catch { /* ignore */ }\n\n  // 2. Try to enumerate all in-memory keys via internal _data and remove legacy per-email entries.\n  //    roamingSettings._data is not part of the public API but is the underlying store in all\n  //    known Office.js web/desktop builds. This cleans up old sc:sent:* keys accumulated before\n  //    the blob-based sentPillStore was introduced.\n  try {\n    const settings = Office.context.roamingSettings as any;\n    const dataStore: Record<string, unknown> | null =\n      settings._data ?? settings._settings?.data ?? null;\n    if (dataStore && typeof dataStore === \"object\") {\n      const allKeys = Object.keys(dataStore);\n      let removedCount = 0;\n      for (const k of allKeys) {\n        if (k.startsWith(\"sc:sent:\") || k.startsWith(\"sc_conv_ctx:\") || k === DEBUG_LOG_KEY) {\n          try { Office.context.roamingSettings.remove(k); removedCount++; } catch { /* ignore */ }\n        }\n      }\n      if (removedCount > 0) {\n        console.warn(\"[emergencyPrune] Removed\", removedCount, \"legacy individual storage entries\");\n      }\n    }\n  } catch { /* ignore if internal API not available */ }\n\n  // 3. Prune sc:sentPills blob to 3 most recent\n  try {\n    const raw = Office.context.roamingSettings.get(\"sc:sentPills\");\n    if (raw) {\n      const blob: Record<string, any> = JSON.parse(String(raw));\n      const entries = Object.entries(blob) as [string, any][];\n      if (entries.length > 3) {\n        entries.sort((a, b) => (b[1]._savedAt || 0) - (a[1]._savedAt || 0));\n        const pruned: Record<string, any> = {};\n        entries.slice(0, 3).forEach(([k, v]) => { pruned[k] = v; });\n        Office.context.roamingSettings.set(\"sc:sentPills\", JSON.stringify(pruned));\n        console.warn(\"[emergencyPrune] Pruned sentPills from\", entries.length, \"to 3 entries\");\n      }\n    }\n  } catch { /* ignore */ }\n\n  // 4. Prune sc:filedEmailsCache to 3 most recent\n  try {\n    const raw = Office.context.roamingSettings.get(\"sc:filedEmailsCache\");\n    if (raw) {\n      const cache: Record<string, any> = JSON.parse(String(raw));\n      const entries = Object.entries(cache) as [string, any][];\n      if (entries.length > 3) {\n        entries.sort((a, b) => (b[1].filedAt || 0) - (a[1].filedAt || 0));\n        const pruned: Record<string, any> = {};\n        entries.slice(0, 3).forEach(([k, v]) => { pruned[k] = v; });\n        Office.context.roamingSettings.set(\"sc:filedEmailsCache\", JSON.stringify(pruned));\n        console.warn(\"[emergencyPrune] Pruned filedCache from\", entries.length, \"to 3 entries\");\n      }\n    }\n  } catch { /* ignore */ }\n}\n\nasync function saveRoamingSettings(): Promise<void> {\n  const startTime = Date.now();\n  if (VERBOSE_LOGGING) console.log(\"[saveRoamingSettings] Starting saveAsync...\");\n\n  await new Promise<void>((resolve, reject) => {\n    try {\n      Office.context.roamingSettings.saveAsync((res: any) => {\n        const duration = Date.now() - startTime;\n        if (res?.status === Office.AsyncResultStatus.Succeeded) {\n          if (VERBOSE_LOGGING) console.log(`[saveRoamingSettings]  Succeeded in ${duration}ms`);\n          resolve();\n        } else {\n          const errorMsg = res?.error?.message || \"roamingSettings.saveAsync failed\";\n          console.error(`[saveRoamingSettings]  Failed in ${duration}ms:`, errorMsg, {\n            status: res?.status,\n            errorCode: res?.error?.code,\n            errorName: res?.error?.name,\n          });\n          reject(new Error(errorMsg));\n        }\n      });\n    } catch (e) {\n      const duration = Date.now() - startTime;\n      console.error(`[saveRoamingSettings]  Exception in ${duration}ms:`, e);\n      reject(e);\n    }\n  });\n\n  // CRITICAL FOR DESKTOP OUTLOOK: Add small delay to ensure operation completes\n  // Desktop Outlook may close compose window immediately after send,\n  // interrupting async operations. This delay ensures saveAsync completes.\n  await new Promise(resolve => setTimeout(resolve, 100));\n}\n\nexport async function getStored(key: string, forceFresh = false): Promise<string | null> {\n  const k = String(key || \"\").trim();\n  if (!k) return null;\n\n  // Detect which storage backend is available\n  const storageBackend = hasOfficeRuntimeStorage()\n    ? \"OfficeRuntime.storage\"\n    : hasRoamingSettings()\n    ? \"roamingSettings\"\n    : \"localStorage\";\n\n  // Only log for important keys to avoid console spam\n  const shouldLog = VERBOSE_LOGGING && !k.includes(\"recipientHistory\") && !k.includes(\"recentCases\");\n\n  if (shouldLog) {\n    console.log(\"[getStored] Using storage backend:\", storageBackend, \"for key:\", k, forceFresh ? \"(force fresh)\" : \"\");\n  }\n\n  const lsGet = (): string | null => {\n    try { return typeof localStorage !== \"undefined\" ? localStorage.getItem(k) : null; } catch { return null; }\n  };\n\n  try {\n    if (hasOfficeRuntimeStorage()) {\n      const v = await (OfficeRuntime as any).storage.getItem(k);\n      if (shouldLog) {\n        console.log(\"[getStored] Got from OfficeRuntime.storage:\", k, v ? `found (${v.length} chars)` : \"not found\");\n      }\n      if (typeof v === \"string\") return v;\n      // setStored may have fallen back to localStorage (e.g. if OfficeRuntime.storage threw).\n      // Also check roamingSettings in case another client wrote there (cross-context sync).\n      if (hasRoamingSettings()) {\n        const rv = Office.context.roamingSettings.get(k);\n        if (typeof rv === \"string\") return rv;\n      }\n      return lsGet();\n    }\n\n    if (hasRoamingSettings()) {\n      // WORKAROUND: roamingSettings can be stale after another instance wrote data\n      // Force a small delay to allow server sync when forceFresh is requested\n      if (forceFresh && VERBOSE_LOGGING) {\n        console.log(\"[getStored] Waiting 500ms for roamingSettings sync...\");\n        await new Promise(resolve => setTimeout(resolve, 500));\n      }\n\n      const v = Office.context.roamingSettings.get(k);\n      if (shouldLog) {\n        console.log(\"[getStored] Got from roamingSettings:\", k, v ? `found (${String(v).length} chars)` : \"not found\");\n      }\n      if (typeof v === \"string\") return v;\n      // setStored may have fallen back to localStorage on saveAsync failure.\n      return lsGet();\n    }\n\n    const v = localStorage.getItem(k);\n    if (shouldLog) {\n      console.warn(\"[getStored] No Office storage, using localStorage:\", k, v ? `found (${v.length} chars)` : \"not found\");\n    }\n    return v;\n  } catch (e) {\n    console.warn(\"[getStored] Failed, falling back to localStorage:\", e);\n    return lsGet();\n  }\n}\n\nexport async function setStored(key: string, value: string, retryCount = 0): Promise<void> {\n  const k = String(key || \"\").trim();\n  if (!k) return;\n\n  const v = String(value ?? \"\");\n  const MAX_RETRIES = 2;\n\n  // Detect which storage backend is available\n  const storageBackend = hasOfficeRuntimeStorage()\n    ? \"OfficeRuntime.storage\"\n    : hasRoamingSettings()\n    ? \"roamingSettings\"\n    : \"localStorage\";\n\n  if (VERBOSE_LOGGING) {\n    console.log(\"[setStored] Using storage backend:\", storageBackend, \"for key:\", k, `(${v.length} chars)`, retryCount > 0 ? `[retry ${retryCount}]` : \"\");\n  }\n\n  // Always mirror to localStorage as belt-and-suspenders backup.\n  // getStored will fall back to localStorage if the primary backend returns null\n  // (e.g. cross-context sync delay between Desktop and OWA, or silent write failure).\n  const lsSet = () => { try { if (typeof localStorage !== \"undefined\") localStorage.setItem(k, v); } catch { /* ignore */ } };\n\n  try {\n    if (hasOfficeRuntimeStorage()) {\n      if (VERBOSE_LOGGING) console.log(\"[setStored] Writing to OfficeRuntime.storage...\");\n      await (OfficeRuntime as any).storage.setItem(k, v);\n      lsSet();\n      if (VERBOSE_LOGGING) console.log(\"[setStored]  Write to OfficeRuntime.storage completed\");\n      return;\n    }\n\n    if (hasRoamingSettings()) {\n      if (VERBOSE_LOGGING) console.log(\"[setStored] Writing to roamingSettings...\");\n      Office.context.roamingSettings.set(k, v);\n      if (VERBOSE_LOGGING) console.log(\"[setStored] Calling saveAsync...\");\n\n      try {\n        await saveRoamingSettings();\n        lsSet();\n        if (VERBOSE_LOGGING) console.log(\"[setStored]  saveAsync completed\");\n        return;\n      } catch (saveError) {\n        console.error(\"[setStored] saveAsync failed:\", saveError);\n\n        // If roamingSettings exceeded 32KB, free space and retry once immediately\n        const isOverflow = (saveError as any)?.message?.includes(\"32 KB\") ||\n                           (saveError as any)?.message?.includes(\"size limit\");\n        if (isOverflow && retryCount === 0) {\n          console.warn(\"[setStored] roamingSettings overflow  emergency pruning and retrying\");\n          emergencyPruneRoamingSettings();\n          try {\n            await saveRoamingSettings();\n            console.log(\"[setStored]  saveAsync succeeded after emergency prune\");\n            return;\n          } catch (retryError) {\n            console.warn(\"[setStored] saveAsync still failed after emergency prune:\", retryError);\n          }\n        }\n\n        // Retry on desktop Outlook if save fails for other reasons\n        if (retryCount < MAX_RETRIES) {\n          const delay = 200 * (retryCount + 1); // Exponential backoff: 200ms, 400ms\n          if (VERBOSE_LOGGING) console.log(`[setStored] Retrying in ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return setStored(key, value, retryCount + 1);\n        }\n\n        throw saveError;\n      }\n    }\n\n    if (VERBOSE_LOGGING) console.warn(\"[setStored] No Office storage, using localStorage for key:\", k);\n    localStorage.setItem(k, v);\n  } catch (e) {\n    console.warn(\"[setStored]  Failed after retries, falling back to localStorage:\", e);\n    localStorage.setItem(k, v);\n  }\n}\n\nexport async function removeStored(key: string): Promise<void> {\n  const k = String(key || \"\").trim();\n  if (!k) return;\n\n  try {\n    if (hasOfficeRuntimeStorage()) {\n      await (OfficeRuntime as any).storage.removeItem(k);\n      return;\n    }\n\n    if (hasRoamingSettings()) {\n      Office.context.roamingSettings.remove(k);\n      await saveRoamingSettings();\n      return;\n    }\n\n    localStorage.removeItem(k);\n  } catch {\n    localStorage.removeItem(k);\n  }\n}","export const STORAGE_KEYS = {\n  onboardingDone: \"sc:onboardingDone\",\n  workspaceId: \"sc:workspaceId\",\n  workspaceName: \"sc:workspaceName\",\n  workspaceHost: \"sc:workspaceHost\",\n  agreementAccepted: \"sc:agreementAccepted\",\n  publicToken: \"sc:publicToken\",\n  recipientHistory: \"recipientHistory\",\n  outlookFolderCache: \"sc:outlookFolderCache\",\n} as const;\n","import { getAuth, getAuthRuntime } from \"./auth\";\nimport { getStored, setStored } from \"../utils/storage\";\nimport { STORAGE_KEYS } from \"../utils/constants\";\n\nexport type UploadDocumentResponse = {\n  documents: Array<{\n    id: string;\n    name: string;\n    mime_type: string;\n    latest_version?: {\n      id: number | string;\n      name: string;\n      revision_number: number;\n    };\n  }>;\n};\n\nexport type UploadDocumentVersionResponse = {\n  id: number | string;\n  name: string;\n  mime_type: string;\n  dir_id?: number | string;\n  latest_version?: {\n    id: number | string;\n    name: string;\n    revision_number: number;\n  };\n};\n\nexport type DocumentMeta = {\n  id: string;\n  name: string;\n  case_id: string;\n};\n\nexport type DirectoryItem = {\n  id: string | number;\n  name: string;\n  type: \"file\" | \"directory\";\n  parent_id?: string | number;\n};\n\nexport type DirectoryListing = {\n  items: DirectoryItem[];\n  parent_id?: string | number;\n};\n\nexport type CreateDirectoryResponse = {\n  id: string | number;\n  name: string;\n  parent_id?: string | number;\n};\n\nfunction normalizeHost(host: string): string {\n  const v = (host || \"\").trim().toLowerCase();\n  if (!v) return \"\";\n  return v.replace(/^https?:\\/\\//i, \"\").split(\"/\")[0];\n}\n\nasync function resolveApiBaseUrl(): Promise<string> {\n  console.log(\"[resolveApiBaseUrl] Reading workspaceHost from storage key:\", STORAGE_KEYS.workspaceHost);\n  const storedHostRaw = await getStored(STORAGE_KEYS.workspaceHost);\n  console.log(\"[resolveApiBaseUrl] Raw stored host:\", storedHostRaw);\n\n  const host = normalizeHost(storedHostRaw || \"\");\n  console.log(\"[resolveApiBaseUrl] Normalized host:\", host);\n\n  if (!host) {\n    console.error(\"[resolveApiBaseUrl] Workspace host is missing\");\n    throw new Error(\"Workspace host is missing.\");\n  }\n\n  const baseUrl = `/singlecase/${encodeURIComponent(host)}/publicapi/v1`;\n  console.log(\"[resolveApiBaseUrl] Resolved base URL:\", baseUrl);\n  return baseUrl;\n}\n\nasync function getToken(): Promise<string> {\n  const auth = getAuth();\n  if (auth?.token) {\n    console.log(\"[getToken] Using sessionStorage token\");\n    return auth.token;\n  }\n\n  console.log(\"[getToken] sessionStorage token not available, trying OfficeRuntime.storage\");\n  const rt = await getAuthRuntime();\n  if (rt?.token) {\n    console.log(\"[getToken] Using OfficeRuntime.storage token\");\n    return rt.token;\n  }\n\n  console.error(\"[getToken] No token found in either sessionStorage or OfficeRuntime.storage\");\n  throw new Error(\"Missing auth token.\");\n}\n\nasync function expectJson(res: Response, errorPrefix: string) {\n  const text = await res.text().catch(() => \"\");\n\n  if (!res.ok) {\n    if (res.status === 423) {\n      throw new Error(\n        \"Dokument je momentln uzamen. Nkdo jej prv upravuje. Pokejte prosm, ne se dokument odemkne, a zkuste to znovu.\"\n      );\n    }\n\n    throw new Error(`${errorPrefix} (${res.status}): ${text || res.statusText}`);\n  }\n\n  const contentType = res.headers.get(\"content-type\") || \"\";\n  if (!contentType.includes(\"application/json\")) {\n    throw new Error(`${errorPrefix}: expected JSON but got ${contentType || \"no content-type\"}.`);\n  }\n\n  return JSON.parse(text);\n}\n\nexport async function getDocumentMeta(documentId: string | number): Promise<DocumentMeta | null> {\n  const token = await getToken();\n\n  const base = await resolveApiBaseUrl();\n  const url = `${base}/documents/${encodeURIComponent(String(documentId))}`;\n\n  const res = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Authentication: token,\n      \"Content-Type\": \"application/json\",\n      \"Accept-Encoding\": \"identity\",\n    },\n  });\n\n  if (res.status === 404) return null;\n\n  const json = await expectJson(res, \"Get document failed\");\n\n  return {\n    id: String((json as any).id || documentId),\n    name: String((json as any).name || \"\"),\n    case_id: String((json as any).case_id || \"\"),\n  };\n}\n\nexport async function uploadDocumentVersion(params: {\n  documentId: string | number;\n  fileName: string;\n  mimeType: string;\n  dataBase64: string;\n  directoryId?: string;\n}): Promise<UploadDocumentVersionResponse> {\n  const { documentId, fileName, mimeType, dataBase64, directoryId } = params;\n\n  const token = await getToken();\n\n  const base = await resolveApiBaseUrl();\n  const id = encodeURIComponent(String(documentId));\n\n  const bodyData: any = {\n    name: fileName,\n    mime_type: mimeType,\n    data_base64: dataBase64,\n  };\n\n  // Add dir_id if provided (though versions typically inherit parent directory)\n  if (directoryId) {\n    bodyData.dir_id = directoryId;\n  }\n\n  const body = JSON.stringify(bodyData);\n\n  const candidates: Array<{ url: string; method: \"POST\" | \"PUT\" | \"PATCH\" }> = [\n    { url: `${base}/documents/${id}/version`, method: \"POST\" },\n    { url: `${base}/documents/${id}/versions`, method: \"POST\" },\n    { url: `${base}/documents/${id}/versions`, method: \"PUT\" },\n    { url: `${base}/documents/${id}/version`, method: \"PUT\" },\n    { url: `${base}/documents/${id}/versions`, method: \"PATCH\" },\n    { url: `${base}/documents/${id}/version`, method: \"PATCH\" },\n  ];\n\n  let lastErr: unknown = null;\n\n  for (const c of candidates) {\n    // eslint-disable-next-line no-await-in-loop\n    const res = await fetch(c.url, {\n      method: c.method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authentication: token,\n        \"Accept-Encoding\": \"identity\",\n      },\n      body,\n    });\n\n    if (res.status === 404 || res.status === 405) {\n      lastErr = new Error(`Endpoint not available: ${c.method} ${c.url} (${res.status})`);\n      continue;\n    }\n\n    // eslint-disable-next-line no-await-in-loop\n    const json = await expectJson(res, \"Upload version failed\");\n    return json as UploadDocumentVersionResponse;\n  }\n\n  throw lastErr instanceof Error ? lastErr : new Error(\"Upload version failed: no supported endpoint found\");\n}\n\nexport async function uploadDocumentToCase(params: {\n  caseId: string;\n  fileName: string;\n  mimeType: string;\n  dataBase64: string;\n  directoryId?: string;\n  metadata?: {\n    subject?: string;\n    fromEmail?: string;\n    fromName?: string;\n    [key: string]: any;\n  };\n}): Promise<UploadDocumentResponse> {\n  const { caseId, fileName, mimeType, dataBase64, directoryId, metadata } = params;\n\n  console.log(\"[uploadDocumentToCase] Starting upload\", {\n    caseId,\n    fileName,\n    mimeType,\n    dataLength: dataBase64.length,\n  });\n\n  let token: string;\n  try {\n    token = await getToken();\n    console.log(\"[uploadDocumentToCase] Token retrieved\", { hasToken: !!token, tokenPrefix: token.slice(0, 10) });\n  } catch (e) {\n    console.error(\"[uploadDocumentToCase] Failed to get token:\", e);\n    throw e;\n  }\n\n  let base: string;\n  try {\n    base = await resolveApiBaseUrl();\n    console.log(\"[uploadDocumentToCase] Base URL resolved:\", base);\n  } catch (e) {\n    console.error(\"[uploadDocumentToCase] Failed to resolve base URL:\", e);\n    throw e;\n  }\n\n  const url = `${base}/documents`;\n  console.log(\"[uploadDocumentToCase] Full URL:\", url);\n\n  const payload: any = {\n    case_id: caseId,\n    documents: [\n      {\n        name: fileName,\n        mime_type: mimeType,\n        data_base64: dataBase64,\n        ...(directoryId ? { dir_id: directoryId } : {}),\n        ...(metadata ? { metadata } : {}),\n      },\n    ],\n  };\n\n  console.log(\"[uploadDocumentToCase] Payload structure:\", {\n    case_id: payload.case_id,\n    documentCount: payload.documents.length,\n    firstDoc: {\n      name: payload.documents[0].name,\n      mime_type: payload.documents[0].mime_type,\n      data_base64_length: payload.documents[0].data_base64.length,\n    },\n  });\n\n  let res: Response;\n  try {\n    res = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authentication: token,\n        \"Accept-Encoding\": \"identity\",\n      },\n      body: JSON.stringify(payload),\n    });\n    console.log(\"[uploadDocumentToCase] Fetch completed\", {\n      status: res.status,\n      statusText: res.statusText,\n      ok: res.ok,\n    });\n  } catch (e) {\n    console.error(\"[uploadDocumentToCase] Fetch failed:\", e);\n    throw new Error(`Network request failed: ${e instanceof Error ? e.message : String(e)}`);\n  }\n\n  if (!res.ok) {\n    const text = await res.text().catch(() => \"\");\n    const snippet = text.slice(0, 300);\n    console.error(\"[uploadDocumentToCase] Upload failed\", {\n      status: res.status,\n      statusText: res.statusText,\n      url,\n      responseSnippet: snippet,\n    });\n  }\n\n  const json = await expectJson(res, \"Upload failed\");\n  console.log(\"[uploadDocumentToCase] Upload successful\", { documentIds: (json as any).documents?.map((d: any) => d.id) });\n  return json as UploadDocumentResponse;\n}\n\nasync function tryRename(url: string, method: string, token: string, name: string) {\n  const res = await fetch(url, {\n    method,\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authentication: token,\n      \"Accept-Encoding\": \"identity\",\n    },\n    body: JSON.stringify({ name }),\n  });\n\n  if (res.ok) {\n    const contentType = res.headers.get(\"content-type\") || \"\";\n    if (contentType.includes(\"application/json\")) return res.json();\n    return {};\n  }\n\n  if (res.status === 404 || res.status === 405) return null;\n\n  const text = await res.text().catch(() => \"\");\n  throw new Error(`Rename document failed (${res.status}): ${text || res.statusText}`);\n}\n\nexport async function renameDocument(params: { token: string; documentId: string; name: string }) {\n  const base = await resolveApiBaseUrl();\n  const id = encodeURIComponent(String(params.documentId));\n\n  const candidates: Array<{ url: string; method: string }> = [\n    { url: `${base}/documents/${id}`, method: \"PUT\" },\n    { url: `${base}/documents/${id}`, method: \"PATCH\" },\n    { url: `${base}/documents/${id}/rename`, method: \"POST\" },\n    { url: `${base}/documents/${id}/name`, method: \"PUT\" },\n  ];\n\n  for (const c of candidates) {\n    // eslint-disable-next-line no-await-in-loop\n    const ok = await tryRename(c.url, c.method, params.token, params.name);\n    if (ok) return ok;\n  }\n\n  throw new Error(\"Rename document failed: API endpoint not found or not allowed\");\n}\n\n// ============================================================================\n// Folder/Directory Management for \"Outlook add-in\" folder\n// ============================================================================\n\nconst OUTLOOK_FOLDER_NAME = \"Outlook add-in\";\n\n/**\n * Get cached folder ID for a case, if available\n */\nasync function getCachedFolderId(caseId: string): Promise<string | null> {\n  try {\n    const raw = await getStored(STORAGE_KEYS.outlookFolderCache);\n    if (!raw) return null;\n\n    const cache = JSON.parse(String(raw));\n    const folderId = cache[String(caseId)];\n    return folderId ? String(folderId) : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Cache folder ID for a case\n */\nasync function cacheFolderId(caseId: string, folderId: string): Promise<void> {\n  try {\n    const raw = await getStored(STORAGE_KEYS.outlookFolderCache);\n    const cache = raw ? JSON.parse(String(raw)) : {};\n\n    cache[String(caseId)] = String(folderId);\n\n    await setStored(STORAGE_KEYS.outlookFolderCache, JSON.stringify(cache));\n  } catch (e) {\n    console.warn(\"[cacheFolderId] Failed to cache folder ID:\", e);\n  }\n}\n\n/**\n * Get the root directory ID for a case\n * Returns null if case has no documents directory yet\n */\nexport async function getCaseRootDirectoryId(caseId: string): Promise<string | null> {\n  const token = await getToken();\n  const base = await resolveApiBaseUrl();\n\n  // Try to get case details which should include root directory info\n  const url = `${base}/cases/${encodeURIComponent(caseId)}`;\n\n  const res = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Authentication: token,\n      \"Content-Type\": \"application/json\",\n      \"Accept-Encoding\": \"identity\",\n    },\n  });\n\n  if (!res.ok) {\n    console.warn(\"[getCaseRootDirectoryId] Failed to get case:\", res.status);\n    return null;\n  }\n\n  const json = await res.json();\n  const rootDirId = (json as any)?.root_directory_id || (json as any)?.documents_directory_id;\n\n  return rootDirId ? String(rootDirId) : null;\n}\n\n/**\n * List contents of a directory\n */\nexport async function listDirectory(directoryId: string): Promise<DirectoryListing> {\n  const token = await getToken();\n  const base = await resolveApiBaseUrl();\n\n  const url = `${base}/directories/${encodeURIComponent(directoryId)}`;\n\n  const res = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Authentication: token,\n      \"Content-Type\": \"application/json\",\n      \"Accept-Encoding\": \"identity\",\n    },\n  });\n\n  if (!res.ok) {\n    throw new Error(`List directory failed (${res.status}): ${res.statusText}`);\n  }\n\n  const json = await res.json();\n  const items: DirectoryItem[] = [];\n\n  // Parse items (structure may vary by API)\n  const rawItems = (json as any)?.items || (json as any)?.children || [];\n  for (const item of rawItems) {\n    items.push({\n      id: String(item.id || item._id),\n      name: String(item.name || \"\"),\n      type: item.type === \"directory\" || item.is_directory ? \"directory\" : \"file\",\n      parent_id: item.parent_id,\n    });\n  }\n\n  return {\n    items,\n    parent_id: (json as any)?.id,\n  };\n}\n\n/**\n * Create a new directory\n */\nexport async function createDirectory(parentId: string, name: string): Promise<CreateDirectoryResponse> {\n  const token = await getToken();\n  const base = await resolveApiBaseUrl();\n\n  const payload = {\n    name,\n    parent_id: parentId,\n  };\n\n  // Try multiple possible endpoints\n  const candidates = [\n    { url: `${base}/directories`, method: \"POST\" },\n    { url: `${base}/directories/${encodeURIComponent(parentId)}/subdirectories`, method: \"POST\" },\n    { url: `${base}/folders`, method: \"POST\" },\n  ];\n\n  let lastError: Error | null = null;\n\n  for (const candidate of candidates) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      const res = await fetch(candidate.url, {\n        method: candidate.method,\n        headers: {\n          Authentication: token,\n          \"Content-Type\": \"application/json\",\n          \"Accept-Encoding\": \"identity\",\n        },\n        body: JSON.stringify(payload),\n      });\n\n      if (res.status === 404 || res.status === 405) {\n        continue; // Try next endpoint\n      }\n\n      if (!res.ok) {\n        const text = await res.text().catch(() => \"\");\n        lastError = new Error(`Create directory failed (${res.status}): ${text || res.statusText}`);\n        continue;\n      }\n\n      const json = await res.json();\n      return {\n        id: String((json as any).id || (json as any)._id),\n        name: String((json as any).name || name),\n        parent_id: (json as any).parent_id,\n      };\n    } catch (e) {\n      lastError = e instanceof Error ? e : new Error(String(e));\n    }\n  }\n\n  throw lastError || new Error(\"Create directory failed: no supported endpoint found\");\n}\n\n/**\n * Ensure the \"Outlook add-in\" folder exists in the case\n * Returns the folder's directory ID\n *\n * This function is idempotent and handles concurrent calls safely\n */\nexport async function ensureOutlookAddinFolder(caseId: string): Promise<string | null> {\n  console.log(\"[ensureOutlookAddinFolder] Starting for case:\", caseId);\n\n  // 1. Check cache first\n  const cachedId = await getCachedFolderId(caseId);\n  if (cachedId) {\n    console.log(\"[ensureOutlookAddinFolder] Using cached folder ID:\", cachedId);\n    return cachedId;\n  }\n\n  // 2. Get case root directory\n  const rootDirId = await getCaseRootDirectoryId(caseId);\n  if (!rootDirId) {\n    console.warn(\"[ensureOutlookAddinFolder] Case has no root directory\");\n    return null;\n  }\n\n  console.log(\"[ensureOutlookAddinFolder] Root directory ID:\", rootDirId);\n\n  // 3. List root directory contents\n  try {\n    const listing = await listDirectory(rootDirId);\n    console.log(\"[ensureOutlookAddinFolder] Found\", listing.items.length, \"items in root\");\n\n    // 4. Check if \"Outlook add-in\" folder already exists\n    const existing = listing.items.find(\n      (item) => item.type === \"directory\" && item.name === OUTLOOK_FOLDER_NAME\n    );\n\n    if (existing) {\n      console.log(\"[ensureOutlookAddinFolder] Folder already exists:\", existing.id);\n      await cacheFolderId(caseId, String(existing.id));\n      return String(existing.id);\n    }\n\n    // 5. Create the folder\n    console.log(\"[ensureOutlookAddinFolder] Creating folder:\", OUTLOOK_FOLDER_NAME);\n    const created = await createDirectory(rootDirId, OUTLOOK_FOLDER_NAME);\n    console.log(\"[ensureOutlookAddinFolder] Folder created:\", created.id);\n\n    await cacheFolderId(caseId, String(created.id));\n    return String(created.id);\n  } catch (e) {\n    console.error(\"[ensureOutlookAddinFolder] Failed:\", e);\n    // Return null - uploads will go to root if folder creation fails\n    return null;\n  }\n}\n\n// ============================================================================\n// Subject-Based Document Matching (for email versioning)\n// ============================================================================\n\n/**\n * Normalize email subject for matching\n * - Trim whitespace\n * - Lowercase\n * - Collapse multiple spaces\n * - Optionally strip Re:/Fw:/Fwd: prefixes\n */\nexport function normalizeSubject(subject: string, stripPrefixes: boolean = true): string {\n  if (!subject) return \"\";\n\n  let normalized = subject.trim().toLowerCase();\n\n  // Collapse multiple spaces to single space\n  normalized = normalized.replace(/\\s+/g, \" \");\n\n  // Optionally strip common reply/forward prefixes\n  if (stripPrefixes) {\n    // Remove Re:, RE:, Fw:, FW:, Fwd:, FWD: (with optional spaces and colons)\n    // Handle multiple nested prefixes like \"Re: Fw: Re: Subject\"\n    let prevLength: number;\n    do {\n      prevLength = normalized.length;\n      normalized = normalized.replace(/^(re|fw|fwd):\\s*/i, \"\");\n    } while (normalized.length !== prevLength && normalized.length > 0);\n  }\n\n  return normalized.trim();\n}\n\nexport type DocumentSearchResult = {\n  id: string;\n  name: string;\n  subject?: string;\n};\n\n/**\n * Search for existing email documents in a case by matching subject\n * Returns the document ID if found, null otherwise\n *\n * This function:\n * 1. Lists all documents in the case\n * 2. Filters for .eml files\n * 3. Compares normalized subjects\n * 4. Returns the first match (or null)\n */\nexport async function findDocumentBySubject(\n  caseId: string,\n  subject: string\n): Promise<DocumentSearchResult | null> {\n  console.log(\"[findDocumentBySubject] Searching for subject in case\", { caseId, subject });\n\n  const token = await getToken();\n  const base = await resolveApiBaseUrl();\n\n  // Try multiple possible endpoints for listing case documents\n  const candidates = [\n    `${base}/cases/${encodeURIComponent(caseId)}/documents`,\n    `${base}/documents?case_id=${encodeURIComponent(caseId)}`,\n    `${base}/cases/${encodeURIComponent(caseId)}/files`,\n  ];\n\n  let documents: any[] = [];\n\n  for (const url of candidates) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      const res = await fetch(url, {\n        method: \"GET\",\n        headers: {\n          Authentication: token,\n          \"Content-Type\": \"application/json\",\n          \"Accept-Encoding\": \"identity\",\n        },\n      });\n\n      if (res.status === 404 || res.status === 405) {\n        continue; // Try next endpoint\n      }\n\n      if (!res.ok) {\n        continue;\n      }\n\n      // eslint-disable-next-line no-await-in-loop\n      const json = await res.json();\n\n      // Handle different response structures\n      documents = Array.isArray(json) ? json :\n                  Array.isArray(json.documents) ? json.documents :\n                  Array.isArray(json.files) ? json.files :\n                  Array.isArray(json.items) ? json.items :\n                  [];\n\n      if (documents.length >= 0) {\n        console.log(\"[findDocumentBySubject] Found\", documents.length, \"documents in case\");\n        break; // Success\n      }\n    } catch {\n      // Try next endpoint\n    }\n  }\n\n  if (documents.length === 0) {\n    console.log(\"[findDocumentBySubject] No documents found in case\");\n    return null;\n  }\n\n  // Normalize search subject\n  const normalizedSearchSubject = normalizeSubject(subject);\n  console.log(\"[findDocumentBySubject] Normalized search subject:\", normalizedSearchSubject);\n\n  if (!normalizedSearchSubject) {\n    console.warn(\"[findDocumentBySubject] Empty normalized subject, skipping\");\n    return null;\n  }\n\n  // Search for .eml files with matching subject\n  for (const doc of documents) {\n    // Check if it's an email document (.eml extension)\n    const fileName = String(doc.name || doc.filename || \"\");\n    if (!fileName.toLowerCase().endsWith(\".eml\")) {\n      continue;\n    }\n\n    // Try to extract subject from multiple possible locations\n    let docSubject =\n      doc.metadata?.subject ||    // Metadata field (if we stored it)\n      doc.subject ||              // Direct field\n      doc.properties?.subject ||  // Properties object\n      \"\";\n\n    // Fallback: extract from filename (remove .eml extension)\n    if (!docSubject) {\n      docSubject = fileName.replace(/\\.eml$/i, \"\");\n    }\n\n    const normalizedDocSubject = normalizeSubject(docSubject);\n\n    console.log(\"[findDocumentBySubject] Comparing\", {\n      fileName,\n      docSubject,\n      normalizedDocSubject,\n      matches: normalizedDocSubject === normalizedSearchSubject,\n    });\n\n    if (normalizedDocSubject === normalizedSearchSubject) {\n      console.log(\"[findDocumentBySubject] Match found!\", {\n        id: doc.id,\n        name: fileName,\n      });\n\n      return {\n        id: String(doc.id || doc._id),\n        name: fileName,\n        subject: docSubject,\n      };\n    }\n  }\n\n  console.log(\"[findDocumentBySubject] No matching document found\");\n  return null;\n}\n\n// ============================================================================\n// Cross-Mailbox Filed Detection (internetMessageId)\n// ============================================================================\n\nexport type FiledDocumentInfo = {\n  documentId: string;\n  caseId: string;\n  caseName?: string;\n  caseKey?: string;\n  subject?: string;\n};\n\n/**\n * Check if an email with this conversationId and subject is already filed\n * Searches across all cases in the workspace\n *\n * This is the definitive server-side check for \"already filed\" status\n * Uses conversationId + normalized subject for reliable cross-mailbox matching\n *\n * @param conversationId - Office.js conversationId (available at send time)\n * @param subject - Email subject for additional matching\n * @returns Document info if found, null otherwise\n */\nexport async function checkFiledStatusByConversationAndSubject(\n  conversationId: string,\n  subject: string\n): Promise<FiledDocumentInfo | null> {\n  if (!conversationId) {\n    console.log(\"[checkFiledStatusByConversationAndSubject] No conversationId provided\");\n    return null;\n  }\n\n  if (!subject) {\n    console.log(\"[checkFiledStatusByConversationAndSubject] No subject provided\");\n    return null;\n  }\n\n  const normalizedSearchSubject = normalizeSubject(subject);\n\n  console.log(\"[checkFiledStatusByConversationAndSubject] Checking:\", {\n    conversationId: conversationId.substring(0, 30) + \"...\",\n    subject,\n    normalizedSubject: normalizedSearchSubject,\n  });\n\n  try {\n    const token = await getToken();\n    const base = await resolveApiBaseUrl();\n\n    // Search for documents by conversationId in metadata\n    // Since backend may not support metadata search, we'll list recent documents and filter manually\n\n    console.log(\"[checkFiledStatusByConversationAndSubject] Fetching recent documents for matching\");\n\n    // Get recently modified documents (last 200 to increase chance of finding match)\n    const listUrl = `${base}/documents?limit=200&sort=-modified_at`;\n    let documents: any[] = [];\n\n    try {\n      const res = await fetch(listUrl, {\n        method: \"GET\",\n        headers: {\n          Authentication: token,\n          \"Content-Type\": \"application/json\",\n          \"Accept-Encoding\": \"identity\",\n        },\n      });\n\n      if (res.ok) {\n        const json = await res.json();\n        documents = Array.isArray(json) ? json :\n                    Array.isArray(json.documents) ? json.documents :\n                    [];\n        console.log(\"[checkFiledStatusByConversationAndSubject] Fetched\", documents.length, \"documents for manual search\");\n      } else {\n        console.warn(\"[checkFiledStatusByConversationAndSubject] Failed to fetch documents:\", res.status);\n        return null;\n      }\n    } catch (e) {\n      console.error(\"[checkFiledStatusByConversationAndSubject] Fetch failed:\", e);\n      return null;\n    }\n\n    // Search through documents for matching conversationId AND normalized subject\n    for (const doc of documents) {\n      // Only check .eml files\n      const fileName = String(doc.name || doc.filename || \"\");\n      if (!fileName.toLowerCase().endsWith(\".eml\")) {\n        continue;\n      }\n\n      // Check conversationId match\n      const docConversationId = doc.metadata?.conversationId;\n      if (!docConversationId || String(docConversationId).trim() !== conversationId.trim()) {\n        continue;\n      }\n\n      // Check subject match (normalized)\n      let docSubject = doc.metadata?.subject || doc.subject || \"\";\n      if (!docSubject) {\n        // Fallback: extract from filename\n        docSubject = fileName.replace(/\\.eml$/i, \"\");\n      }\n\n      const normalizedDocSubject = normalizeSubject(docSubject);\n\n      if (normalizedDocSubject === normalizedSearchSubject) {\n        console.log(\"[checkFiledStatusByConversationAndSubject] Match found!\", {\n          documentId: doc.id,\n          caseId: doc.case_id,\n          subject: docSubject,\n          conversationIdMatch: true,\n          subjectMatch: true,\n        });\n\n        return {\n          documentId: String(doc.id || doc._id),\n          caseId: String(doc.case_id || doc.caseId),\n          caseName: doc.case_name || doc.caseName,\n          caseKey: doc.case_key || doc.caseKey,\n          subject: docSubject,\n        };\n      }\n    }\n\n    console.log(\"[checkFiledStatusByConversationAndSubject] No match found (checked\", documents.length, \"documents)\");\n    return null;\n  } catch (e) {\n    console.error(\"[checkFiledStatusByConversationAndSubject] Error:\", e);\n    return null;\n  }\n}","import { getStored, setStored } from \"./storage\";\n\nconst FILED_CACHE_KEY = \"sc:filedEmailsCache\";\n\nexport type FiledEmailCache = {\n  [conversationId: string]: {\n    caseId: string;\n    documentId: string;\n    subject: string;\n    caseName?: string;\n    caseKey?: string;\n    filedAt: number; // timestamp\n  };\n};\n\n/**\n * Store filed email info by conversationId\n * This enables \"already filed\" detection for self-sent emails and replies\n *\n * Works for:\n * - Self-sent emails (sender opens received copy)\n * - Sent items (user reopens their own sent email)\n * - Replies in same thread (same conversationId)\n */\nexport async function cacheFiledEmail(\n  conversationId: string,\n  caseId: string,\n  documentId: string,\n  subject: string,\n  caseName?: string,\n  caseKey?: string\n): Promise<void> {\n  if (!conversationId) {\n    console.warn(\"[cacheFiledEmail] No conversationId provided, skipping cache\");\n    return;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[cacheFiledEmail] Platform info:\", platform);\n\n    const raw = await getStored(FILED_CACHE_KEY);\n    const cache: FiledEmailCache = raw ? JSON.parse(String(raw)) : {};\n    console.log(\"[cacheFiledEmail] Current cache size:\", Object.keys(cache).length);\n\n    cache[conversationId] = {\n      caseId,\n      documentId,\n      subject,\n      caseName,\n      caseKey,\n      filedAt: Date.now(),\n    };\n\n    // Always prune to 8 most recent entries to stay well under the 32KB roamingSettings limit\n    const entries = Object.entries(cache);\n    entries.sort((a, b) => b[1].filedAt - a[1].filedAt);\n    const keep = entries.slice(0, 8);\n    const newCache: FiledEmailCache = {};\n    keep.forEach(([key, val]) => {\n      newCache[key] = val;\n    });\n    await setStored(FILED_CACHE_KEY, JSON.stringify(newCache));\n    if (entries.length > 8) {\n      console.log(\"[cacheFiledEmail] Pruned cache from\", entries.length, \"to 8 entries\");\n    }\n\n    // Verify write succeeded\n    const verification = await getStored(FILED_CACHE_KEY);\n    const verifiedCache = verification ? JSON.parse(String(verification)) : {};\n    const writeSuccess = !!verifiedCache[conversationId];\n    console.log(\"[cacheFiledEmail] Write verification:\", {\n      success: writeSuccess,\n      cacheSize: Object.keys(verifiedCache).length,\n    });\n\n    console.log(\"[cacheFiledEmail] Cached filed email\", {\n      conversationId: conversationId.substring(0, 20) + \"...\",\n      caseId,\n      documentId,\n      subject,\n      writeVerified: writeSuccess,\n    });\n  } catch (e) {\n    console.warn(\"[cacheFiledEmail] Failed to cache:\", e);\n    // Non-critical, don't throw\n  }\n}\n\n/**\n * Check if email with this conversationId was filed\n * Returns cached info if found, null otherwise\n */\nexport async function getFiledEmailFromCache(\n  conversationId: string\n): Promise<FiledEmailCache[string] | null> {\n  if (!conversationId) {\n    return null;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[getFiledEmailFromCache] Platform info:\", platform);\n\n    // Force fresh read to avoid stale roamingSettings after recent write\n    const raw = await getStored(FILED_CACHE_KEY, true);\n    if (!raw) {\n      console.log(\"[getFiledEmailFromCache] No cache found in storage\");\n      return null;\n    }\n\n    const cache: FiledEmailCache = JSON.parse(String(raw));\n    const cacheKeys = Object.keys(cache);\n    console.log(\"[getFiledEmailFromCache] Cache size:\", cacheKeys.length, \"keys\");\n    console.log(\"[getFiledEmailFromCache] Looking for conversationId:\", conversationId.substring(0, 30) + \"...\");\n    console.log(\"[getFiledEmailFromCache] Sample cache keys:\", cacheKeys.slice(0, 3).map(k => k.substring(0, 30) + \"...\"));\n\n    const entry = cache[conversationId];\n\n    if (entry) {\n      console.log(\"[getFiledEmailFromCache]  Found cache entry\", {\n        conversationId: conversationId.substring(0, 20) + \"...\",\n        caseId: entry.caseId,\n        documentId: entry.documentId,\n        filedAt: new Date(entry.filedAt).toISOString(),\n        subject: entry.subject,\n      });\n      return entry;\n    }\n\n    console.log(\"[getFiledEmailFromCache]  No entry for this conversationId\");\n    return null;\n  } catch (e) {\n    console.warn(\"[getFiledEmailFromCache] Failed to read cache:\", e);\n    return null;\n  }\n}\n\n/**\n * Cache filed email by subject (fallback when conversationId not available at send time)\n * Used for NEW compose emails where conversationId isn't assigned until after send\n */\nexport async function cacheFiledEmailBySubject(\n  subject: string,\n  caseId: string,\n  documentId: string,\n  caseName?: string,\n  caseKey?: string\n): Promise<void> {\n  if (!subject) {\n    console.warn(\"[cacheFiledEmailBySubject] No subject provided, skipping cache\");\n    return;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[cacheFiledEmailBySubject] Platform info:\", platform);\n\n    const raw = await getStored(FILED_CACHE_KEY);\n    const cache: FiledEmailCache = raw ? JSON.parse(String(raw)) : {};\n    console.log(\"[cacheFiledEmailBySubject] Current cache size:\", Object.keys(cache).length);\n\n    // Use subject as temporary key (prefixed with \"subj:\")\n    const tempKey = `subj:${subject.trim().toLowerCase()}`;\n    console.log(\"[cacheFiledEmailBySubject] Using temp key:\", tempKey);\n\n    cache[tempKey] = {\n      caseId,\n      documentId,\n      subject,\n      caseName,\n      caseKey,\n      filedAt: Date.now(),\n    };\n\n    // Always prune to 8 most recent entries to stay well under the 32KB roamingSettings limit\n    const entries = Object.entries(cache);\n    entries.sort((a, b) => b[1].filedAt - a[1].filedAt);\n    const keep = entries.slice(0, 8);\n    const newCache: FiledEmailCache = {};\n    keep.forEach(([key, val]) => {\n      newCache[key] = val;\n    });\n    await setStored(FILED_CACHE_KEY, JSON.stringify(newCache));\n    if (entries.length > 8) {\n      console.log(\"[cacheFiledEmailBySubject] Pruned cache from\", entries.length, \"to 8 entries\");\n    }\n\n    // Verify write succeeded\n    const verification = await getStored(FILED_CACHE_KEY);\n    const verifiedCache = verification ? JSON.parse(String(verification)) : {};\n    const writeSuccess = !!verifiedCache[tempKey];\n    console.log(\"[cacheFiledEmailBySubject] Write verification:\", {\n      success: writeSuccess,\n      cacheSize: Object.keys(verifiedCache).length,\n      tempKey,\n    });\n\n    console.log(\"[cacheFiledEmailBySubject] Cached filed email by subject\", {\n      subject,\n      caseId,\n      documentId,\n      writeVerified: writeSuccess,\n    });\n  } catch (e) {\n    console.warn(\"[cacheFiledEmailBySubject] Failed to cache:\", e);\n  }\n}\n\n/**\n * Search cache by subject (fallback when conversationId lookup fails)\n * Also upgrades the cache entry to use conversationId for future lookups\n */\nexport async function findFiledEmailBySubject(\n  subject: string,\n  conversationId?: string\n): Promise<FiledEmailCache[string] | null> {\n  if (!subject) {\n    return null;\n  }\n\n  try {\n    // Platform detection\n    const platform = {\n      host: (Office as any)?.context?.mailbox?.diagnostics?.hostName,\n      hostVersion: (Office as any)?.context?.mailbox?.diagnostics?.hostVersion,\n      platform: (Office as any)?.context?.platform,\n    };\n    console.log(\"[findFiledEmailBySubject] Platform info:\", platform);\n\n    // Force fresh read to avoid stale roamingSettings after recent write\n    const raw = await getStored(FILED_CACHE_KEY, true);\n    if (!raw) {\n      console.log(\"[findFiledEmailBySubject] No cache found in storage\");\n      return null;\n    }\n\n    const cache: FiledEmailCache = JSON.parse(String(raw));\n    const cacheKeys = Object.keys(cache);\n    console.log(\"[findFiledEmailBySubject] Cache size:\", cacheKeys.length, \"keys\");\n\n    const tempKey = `subj:${subject.trim().toLowerCase()}`;\n    console.log(\"[findFiledEmailBySubject] Looking for temp key:\", tempKey);\n    console.log(\"[findFiledEmailBySubject] Subject-based keys in cache:\", cacheKeys.filter(k => k.startsWith(\"subj:\")).length);\n\n    const entry = cache[tempKey];\n\n    if (entry) {\n      console.log(\"[findFiledEmailBySubject]  Found cache entry by subject\", {\n        subject,\n        caseId: entry.caseId,\n        documentId: entry.documentId,\n        filedAt: new Date(entry.filedAt).toISOString(),\n      });\n\n      // Upgrade cache: If we now have conversationId, store under that key too\n      if (conversationId) {\n        console.log(\"[findFiledEmailBySubject] Upgrading cache with conversationId:\", conversationId.substring(0, 30) + \"...\");\n        cache[conversationId] = entry;\n        // Keep the subject-based entry for a while (don't delete)\n        await setStored(FILED_CACHE_KEY, JSON.stringify(cache));\n\n        // Verify upgrade succeeded\n        const verification = await getStored(FILED_CACHE_KEY);\n        const verifiedCache = verification ? JSON.parse(String(verification)) : {};\n        const upgradeSuccess = !!verifiedCache[conversationId];\n        console.log(\"[findFiledEmailBySubject] Cache upgrade verification:\", {\n          success: upgradeSuccess,\n          cacheSize: Object.keys(verifiedCache).length,\n        });\n      }\n\n      return entry;\n    }\n\n    console.log(\"[findFiledEmailBySubject]  No entry for this subject\");\n    return null;\n  } catch (e) {\n    console.warn(\"[findFiledEmailBySubject] Failed:\", e);\n    return null;\n  }\n}\n\n/**\n * Remove filed email from cache (e.g., if document was deleted)\n */\nexport async function removeFiledEmailFromCache(conversationId: string): Promise<void> {\n  if (!conversationId) {\n    return;\n  }\n\n  try {\n    const raw = await getStored(FILED_CACHE_KEY);\n    if (!raw) return;\n\n    const cache: FiledEmailCache = JSON.parse(String(raw));\n    delete cache[conversationId];\n\n    await setStored(FILED_CACHE_KEY, JSON.stringify(cache));\n    console.log(\"[removeFiledEmailFromCache] Removed entry\", {\n      conversationId: conversationId.substring(0, 20) + \"...\",\n    });\n  } catch (e) {\n    console.warn(\"[removeFiledEmailFromCache] Failed:\", e);\n  }\n}\n","/* global Office, OfficeRuntime */\n\nimport { getAuthRuntime, clearAuthIfExpiredRuntime } from \"../services/auth\";\nimport { getStored, setStored } from \"../utils/storage\";\nimport { STORAGE_KEYS } from \"../utils/constants\";\nimport { uploadDocumentToCase, uploadDocumentVersion, findDocumentBySubject } from \"../services/singlecaseDocuments\";\nimport { cacheFiledEmail, cacheFiledEmailBySubject } from \"../utils/filedCache\";\n\ntype SendEvent = Office.AddinCommands.Event;\n\nconst T_ITEMKEY_MS = 2000;\nconst T_STORAGE_MS = 1500;\nconst T_FETCH_MS = 10000;\nconst T_SUBJECT_MS = 1500;\nconst T_BODY_MS = 2500;\n\nconst CONV_CTX_KEY_PREFIX = \"sc_conv_ctx:\";\nconst LAST_FILED_CTX_KEY = \"sc_last_filed_ctx\";\n\nfunction withTimeout<T>(p: Promise<T>, ms: number): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const t = setTimeout(() => reject(new Error(\"timeout\")), ms);\n    p.then(\n      (v) => {\n        clearTimeout(t);\n        resolve(v);\n      },\n      (e) => {\n        clearTimeout(t);\n        reject(e);\n      }\n    );\n  });\n}\n\nfunction normalizeHost(host: string): string {\n  const v = (host || \"\").trim().toLowerCase();\n  if (!v) return \"\";\n  return v.replace(/^https?:\\/\\//i, \"\").split(\"/\")[0];\n}\n\nfunction safeFileName(value: string): string {\n  const v = (value || \"\").trim();\n  const cleaned = v\n    .replace(/[<>:\"/\\\\|?*\\x00-\\x1F]/g, \" \")\n    .replace(/\\s+/g, \" \")\n    .trim();\n  return cleaned.slice(0, 80) || \"email\";\n}\n\nfunction toBase64Utf8(text: string): string {\n  const bytes = new TextEncoder().encode(text);\n  let binary = \"\";\n  for (let i = 0; i < bytes.length; i += 1) binary += String.fromCharCode(bytes[i]);\n  return btoa(binary);\n}\n\nfunction getConversationIdSafe(): string {\n  try {\n    const item = Office.context.mailbox.item as any;\n    return String(item?.conversationId || item?.conversationKey || \"\").trim();\n  } catch {\n    return \"\";\n  }\n}\n\nasync function persistFiledCtx(caseId: string, emailDocId: string) {\n  const cid = String(caseId || \"\").trim();\n  const did = String(emailDocId || \"\").trim();\n  if (!cid || !did) return;\n\n  const payload = JSON.stringify({ caseId: cid, emailDocId: did });\n\n  // Always keep a last-known base\n  try {\n    await setStored(LAST_FILED_CTX_KEY, payload);\n  } catch {\n    // ignore\n  }\n\n  // And also map per conversation where possible\n  try {\n    const convId = getConversationIdSafe();\n    if (convId) {\n      await setStored(`${CONV_CTX_KEY_PREFIX}${convId}`, payload);\n    }\n  } catch {\n    // ignore\n  }\n}\n\nasync function getCandidateItemKeysRuntime(): Promise<string[]> {\n  const item = Office.context.mailbox.item as any;\n  if (!item) {\n    console.warn(\"[getCandidateItemKeysRuntime] No item available\");\n    return [];\n  }\n\n  console.log(\"[getCandidateItemKeysRuntime] Item properties:\", {\n    hasItemId: !!item.itemId,\n    itemId: String(item.itemId || \"\").substring(0, 20),\n    hasConversationId: !!item.conversationId,\n    conversationId: String(item.conversationId || \"\").substring(0, 20),\n    hasConversationKey: !!item.conversationKey,\n    hasDateTimeCreated: !!item.dateTimeCreated,\n    hasGetItemIdAsync: typeof item.getItemIdAsync === \"function\",\n    itemType: item.itemType,\n  });\n\n  const keys: string[] = [];\n\n  const direct = String(item.itemId || \"\").trim();\n  if (direct) keys.push(direct);\n\n  if (typeof item.getItemIdAsync === \"function\") {\n    try {\n      const asyncId: string = await new Promise((resolve) => {\n        item.getItemIdAsync((res: any) => {\n          if (res?.status === Office.AsyncResultStatus.Succeeded) resolve(String(res.value || \"\"));\n          else resolve(\"\");\n        });\n      });\n      if (asyncId) {\n        console.log(\n          \"[getCandidateItemKeysRuntime] getItemIdAsync returned:\",\n          asyncId.substring(0, 20)\n        );\n        keys.push(asyncId);\n      }\n    } catch (e) {\n      console.warn(\"[getCandidateItemKeysRuntime] getItemIdAsync failed:\", e);\n    }\n  }\n\n  const conv = String(item.conversationId || item.conversationKey || \"\").trim();\n  if (conv) keys.push(`draft:${conv}`);\n\n  const created = String(item.dateTimeCreated || \"\").trim();\n  if (created) keys.push(`draft:${created}`);\n\n  // Always include fallback keys for new compose emails\n  keys.push(\"draft:current\");\n  keys.push(\"last_compose\");\n\n  console.log(\"[getCandidateItemKeysRuntime] Generated keys:\", keys);\n\n  return Array.from(new Set(keys.filter(Boolean)));\n}\n\nasync function readIntentAny(\n  itemKeys: string[]\n): Promise<{\n  itemKey: string;\n  caseId: string;\n  autoFileOnSend: boolean;\n  baseCaseId?: string;\n  baseEmailDocId?: string;\n} | null> {\n  for (const k of itemKeys) {\n    const key = `sc_intent:${k}`;\n    console.log(\"[readIntentAny] Trying key:\", key);\n\n    try {\n      let raw: string | null = null;\n\n      if (typeof OfficeRuntime !== \"undefined\" && (OfficeRuntime as any)?.storage) {\n        try {\n          raw = await (OfficeRuntime as any).storage.getItem(key);\n          if (raw) console.log(\"[readIntentAny] Found in OfficeRuntime.storage\");\n        } catch (e) {\n          console.warn(\"[readIntentAny] OfficeRuntime.storage.getItem failed:\", e);\n        }\n      }\n\n      if (!raw && Office?.context?.roamingSettings) {\n        try {\n          raw = Office.context.roamingSettings.get(key);\n          if (raw) console.log(\"[readIntentAny] Found in roamingSettings\");\n        } catch (e) {\n          console.warn(\"[readIntentAny] roamingSettings.get failed:\", e);\n        }\n      }\n\n      if (!raw) continue;\n\n      const obj = JSON.parse(String(raw));\n      const caseId = String(obj?.caseId || \"\").trim();\n      const autoFileOnSend = Boolean(obj?.autoFileOnSend);\n      const baseCaseId = String(obj?.baseCaseId || \"\").trim();\n      const baseEmailDocId = String(obj?.baseEmailDocId || \"\").trim();\n\n      if (!caseId) continue;\n\n      console.log(\"[readIntentAny] Intent found:\", {\n        itemKey: k,\n        caseId,\n        autoFileOnSend,\n        hasBase: !!(baseCaseId && baseEmailDocId),\n      });\n\n      return {\n        itemKey: k,\n        caseId,\n        autoFileOnSend,\n        baseCaseId: baseCaseId || undefined,\n        baseEmailDocId: baseEmailDocId || undefined,\n      };\n    } catch (e) {\n      console.warn(\"[readIntentAny] Failed to read intent for key:\", key, e);\n    }\n  }\n\n  console.warn(\"[readIntentAny] No intent found for any key\");\n  return null;\n}\n\nasync function getSubjectRuntime(): Promise<string> {\n  const item = Office.context.mailbox.item as any;\n  if (!item) {\n    console.warn(\"[getSubjectRuntime] No item available\");\n    return \"\";\n  }\n\n  console.log(\"[getSubjectRuntime] Item type:\", item.itemType, \"Mode:\", item.itemClass);\n\n  if (typeof item.subject === \"string\") {\n    const subj = String(item.subject || \"\");\n    console.log(\"[getSubjectRuntime] Direct string subject:\", subj);\n    return subj;\n  }\n\n  if (item?.subject?.getAsync) {\n    const v: string = await new Promise((resolve) => {\n      item.subject.getAsync((res: any) => {\n        if (res?.status === Office.AsyncResultStatus.Succeeded) {\n          const subj = String(res.value || \"\");\n          console.log(\"[getSubjectRuntime] Async subject:\", subj);\n          resolve(subj);\n        } else {\n          console.warn(\"[getSubjectRuntime] getAsync failed:\", res?.error);\n          resolve(\"\");\n        }\n      });\n    });\n    return v || \"\";\n  }\n\n  console.warn(\"[getSubjectRuntime] No subject API available\");\n  return \"\";\n}\n\nasync function getBodyTextRuntime(): Promise<string> {\n  const item = Office.context.mailbox.item as any;\n  if (!item?.body?.getAsync) return \"\";\n\n  const text: string = await new Promise((resolve) => {\n    item.body.getAsync(Office.CoercionType.Text, (res: any) => {\n      if (res?.status === Office.AsyncResultStatus.Succeeded) resolve(String(res.value || \"\"));\n      else resolve(\"\");\n    });\n  });\n\n  return String(text || \"\");\n}\n\nasync function showInfo(message: string) {\n  try {\n    const item: any = Office.context.mailbox.item;\n    if (!item?.notificationMessages?.replaceAsync) return;\n\n    await new Promise<void>((resolve) => {\n      item.notificationMessages.replaceAsync(\n        \"sc_send\",\n        {\n          type: \"informationalMessage\",\n          message,\n          icon: \"Icon.16x16\",\n          persistent: false,\n        },\n        () => resolve()\n      );\n    });\n  } catch {\n    // ignore\n  }\n}\n\nexport async function onMessageSendHandler(event: SendEvent) {\n  console.log(\"[onMessageSendHandler] Handler fired\");\n  console.log(\"[onMessageSendHandler] Platform info\", {\n    hasOfficeRuntime: typeof OfficeRuntime !== \"undefined\",\n    hasOfficeRuntimeStorage: typeof (OfficeRuntime as any)?.storage !== \"undefined\",\n    hasRoamingSettings: !!Office?.context?.roamingSettings,\n    host: Office?.context?.mailbox?.diagnostics?.hostName,\n    hostVersion: Office?.context?.mailbox?.diagnostics?.hostVersion,\n  });\n\n  let done = false;\n\n  const finish = (allowEvent: boolean, errorMessage?: string) => {\n    if (done) return;\n    done = true;\n    console.log(\"[onMessageSendHandler] Finishing\", { allowEvent, hasErrorMessage: !!errorMessage });\n    try {\n      if (errorMessage) (event.completed as any)({ allowEvent, errorMessage });\n      else event.completed({ allowEvent });\n    } catch (e) {\n      console.error(\"[onMessageSendHandler] Error in event.completed:\", e);\n    }\n  };\n\n  try {\n    console.log(\"[onMessageSendHandler] Clearing expired auth\");\n    await withTimeout(clearAuthIfExpiredRuntime(), 700);\n\n    console.log(\"[onMessageSendHandler] Getting candidate item keys\");\n    const keys = await withTimeout(getCandidateItemKeysRuntime(), T_ITEMKEY_MS);\n    console.log(\"[onMessageSendHandler] Item keys:\", keys);\n\n    if (keys.length === 0) {\n      console.log(\"[onMessageSendHandler] No item keys found, skipping\");\n      finish(true);\n      return;\n    }\n\n    console.log(\"[onMessageSendHandler] Reading intent from storage\", {\n      storageType: typeof OfficeRuntime !== \"undefined\" && (OfficeRuntime as any)?.storage ? \"OfficeRuntime\" : \"roamingSettings\",\n      keysToTry: keys,\n    });\n    const intent = await withTimeout(readIntentAny(keys), T_STORAGE_MS);\n    console.log(\"[onMessageSendHandler] Intent:\", intent, {\n      found: !!intent,\n      foundUnderKey: intent?.itemKey,\n    });\n\n    if (!intent?.autoFileOnSend || !intent.caseId) {\n      console.log(\"[onMessageSendHandler] No auto-file intent or case ID, skipping\");\n      finish(true);\n      return;\n    }\n\n    // Migrate intent from fallback key to real itemId if needed\n    try {\n      const isFallbackKey =\n        intent.itemKey === \"draft:current\" || intent.itemKey === \"last_compose\";\n\n      if (isFallbackKey) {\n        // Find the real itemId from keys (first non-draft key)\n        const realItemId = keys.find((k) => !k.startsWith(\"draft:\") && k !== \"last_compose\");\n\n        if (realItemId) {\n          console.log(\"[onMessageSendHandler] Migrating intent from fallback\", {\n            from: intent.itemKey,\n            to: realItemId,\n          });\n\n          const intentValue = JSON.stringify({\n            caseId: intent.caseId,\n            autoFileOnSend: intent.autoFileOnSend,\n            baseCaseId: intent.baseCaseId || \"\",\n            baseEmailDocId: intent.baseEmailDocId || \"\",\n          });\n\n          const realKey = `sc_intent:${realItemId}`;\n\n          // Save under real itemId\n          if (typeof OfficeRuntime !== \"undefined\" && (OfficeRuntime as any)?.storage) {\n            await (OfficeRuntime as any).storage.setItem(realKey, intentValue);\n            console.log(\"[onMessageSendHandler] Migrated to OfficeRuntime.storage\");\n          } else if (Office?.context?.roamingSettings) {\n            Office.context.roamingSettings.set(realKey, intentValue);\n            await new Promise<void>((resolve) => {\n              Office.context.roamingSettings.saveAsync(() => resolve());\n            });\n            console.log(\"[onMessageSendHandler] Migrated to roamingSettings\");\n          }\n\n          // Clear fallback key\n          const fallbackKey = `sc_intent:${intent.itemKey}`;\n          if (typeof OfficeRuntime !== \"undefined\" && (OfficeRuntime as any)?.storage) {\n            await (OfficeRuntime as any).storage.removeItem(fallbackKey);\n            console.log(\"[onMessageSendHandler] Cleared fallback key from OfficeRuntime.storage\");\n          } else if (Office?.context?.roamingSettings) {\n            Office.context.roamingSettings.remove(fallbackKey);\n            await new Promise<void>((resolve) => {\n              Office.context.roamingSettings.saveAsync(() => resolve());\n            });\n            console.log(\"[onMessageSendHandler] Cleared fallback key from roamingSettings\");\n          }\n        }\n      }\n    } catch (e) {\n      console.warn(\"[onMessageSendHandler] Intent migration failed (non-critical):\", e);\n    }\n\n    console.log(\"[onMessageSendHandler] Getting auth token\");\n    const { token } = await withTimeout(getAuthRuntime(), 900);\n    if (!token) {\n      console.error(\"[onMessageSendHandler] No auth token available\");\n      await showInfo(\"SingleCase: chyb pihlen, nelze zaadit pi odesln.\");\n      finish(true);\n      return;\n    }\n    console.log(\"[onMessageSendHandler] Token retrieved\", { tokenPrefix: token.slice(0, 10) });\n\n    console.log(\"[onMessageSendHandler] Getting workspace host\");\n    const hostRaw = (await getStored(STORAGE_KEYS.workspaceHost)) || \"\";\n    const host = normalizeHost(hostRaw);\n    console.log(\"[onMessageSendHandler] Workspace host\", { hostRaw, normalized: host });\n\n    if (!host) {\n      console.error(\"[onMessageSendHandler] No workspace host configured\");\n      await showInfo(\"SingleCase: chyb workspace URL, nelze zaadit pi odesln.\");\n      finish(true);\n      return;\n    }\n\n    console.log(\"[onMessageSendHandler] Skipping pre-flight check, proceeding to upload\");\n\n    console.log(\"[onMessageSendHandler] Reading email metadata\");\n    console.log(\"[onMessageSendHandler] Current item info:\", {\n      itemType: (Office.context.mailbox.item as any)?.itemType,\n      itemClass: (Office.context.mailbox.item as any)?.itemClass,\n      hasSubject: !!(Office.context.mailbox.item as any)?.subject,\n    });\n    const subject = await withTimeout(getSubjectRuntime(), T_SUBJECT_MS);\n    const bodyText = await withTimeout(getBodyTextRuntime(), T_BODY_MS);\n\n    // For new compose, item.from is empty - fallback to userProfile\n    const itemFrom = (Office.context.mailbox.item as any)?.from;\n    const fromEmail = String(\n      itemFrom?.emailAddress ||\n      Office.context.mailbox.userProfile?.emailAddress ||\n      \"\"\n    );\n    const fromName = String(\n      itemFrom?.displayName ||\n      Office.context.mailbox.userProfile?.displayName ||\n      \"\"\n    );\n\n    // Extract conversationId (cross-mailbox identifier, available at send time)\n    const conversationId = getConversationIdSafe();\n\n    console.log(\"[onMessageSendHandler] Email metadata\", {\n      subject,\n      fromEmail,\n      fromName,\n      bodyLength: bodyText.length,\n      hasConversationId: !!conversationId,\n      conversationIdPreview: conversationId ? conversationId.substring(0, 30) + \"...\" : \"(none)\",\n    });\n\n    const baseName = safeFileName(subject || \"email\");\n\n    const emailText =\n      `From: ${fromName} <${fromEmail}>\\r\\n` +\n      `To: SingleCase <noreply@singlecase>\\r\\n` +\n      `Subject: ${subject}\\r\\n` +\n      `Date: ${new Date().toUTCString()}\\r\\n` +\n      `Message-ID: <${keys[0]}@outlook>\\r\\n` +\n      `MIME-Version: 1.0\\r\\n` +\n      `Content-Type: text/plain; charset=UTF-8\\r\\n` +\n      `Content-Transfer-Encoding: 8bit\\r\\n` +\n      `\\r\\n` +\n      `${(bodyText || \"\").trim()}\\r\\n`;\n\n    const emailBase64 = toBase64Utf8(emailText);\n    console.log(\"[onMessageSendHandler] EML built\", { length: emailBase64.length });\n\n    // NEW: Subject-based versioning decision\n    // Check if a document with this subject already exists in the case\n    let existingDoc: Awaited<ReturnType<typeof findDocumentBySubject>> = null;\n\n    try {\n      console.log(\"[onMessageSendHandler] Checking for existing document with same subject\");\n      existingDoc = await withTimeout(\n        findDocumentBySubject(intent.caseId, subject),\n        T_FETCH_MS\n      );\n\n      if (existingDoc) {\n        console.log(\"[onMessageSendHandler] Found existing document\", {\n          docId: existingDoc.id,\n          docName: existingDoc.name,\n          docSubject: existingDoc.subject,\n        });\n      } else {\n        console.log(\"[onMessageSendHandler] No existing document with this subject found\");\n      }\n    } catch (e) {\n      console.warn(\"[onMessageSendHandler] Failed to check for existing document:\", e);\n      // Continue with new document creation on error\n      existingDoc = null;\n    }\n\n    const shouldUploadVersion = !!existingDoc;\n\n    console.log(\"[onMessageSendHandler] Version decision\", {\n      caseId: intent.caseId,\n      subject,\n      existingDocId: existingDoc?.id,\n      existingDocName: existingDoc?.name,\n      shouldUploadVersion,\n    });\n\n    if (shouldUploadVersion && existingDoc) {\n      // Upload as new version of existing document\n      console.log(\"[onMessageSendHandler] Uploading as version of existing document:\", existingDoc.id);\n\n      await withTimeout(\n        uploadDocumentVersion({\n          documentId: existingDoc.id,\n          fileName: `${baseName}.eml`,\n          mimeType: \"message/rfc822\",\n          dataBase64: emailBase64,\n        }),\n        T_FETCH_MS\n      );\n\n      console.log(\"[onMessageSendHandler] Version uploaded successfully\");\n\n      // Update filed context with the existing document ID\n      await persistFiledCtx(intent.caseId, existingDoc.id);\n\n      // NEW: Cache filed email for \"already filed\" detection\n      const conversationId = getConversationIdSafe();\n      if (conversationId) {\n        await cacheFiledEmail(\n          conversationId,\n          intent.caseId,\n          existingDoc.id,\n          subject\n        );\n        console.log(\"[onMessageSendHandler] Cached filed email (version)\", { conversationId: conversationId.substring(0, 20) + \"...\" });\n      } else {\n        // Fallback: Cache by subject when conversationId not available (new compose emails)\n        await cacheFiledEmailBySubject(\n          subject,\n          intent.caseId,\n          existingDoc.id\n        );\n        console.log(\"[onMessageSendHandler] Cached filed email by subject (version)\", { subject });\n      }\n    } else {\n      // Upload as new document\n      console.log(\"[onMessageSendHandler] Uploading as new document\");\n\n      const created = await withTimeout(\n        uploadDocumentToCase({\n          caseId: intent.caseId,\n          fileName: `${baseName}.eml`,\n          mimeType: \"message/rfc822\",\n          dataBase64: emailBase64,\n          metadata: {\n            subject,\n            fromEmail,\n            fromName,\n            conversationId: conversationId || undefined, // Cross-mailbox identifier\n          },\n        }),\n        T_FETCH_MS\n      );\n\n      const docs = (created as any)?.documents;\n      const createdDocId = Array.isArray(docs) && docs[0]?.id ? String(docs[0].id) : \"\";\n\n      console.log(\"[onMessageSendHandler] Created docId\", { createdDocId, rawResponse: created });\n\n      if (createdDocId) {\n        await persistFiledCtx(intent.caseId, createdDocId);\n\n        // NEW: Cache filed email for \"already filed\" detection\n        const conversationId = getConversationIdSafe();\n        if (conversationId) {\n          await cacheFiledEmail(\n            conversationId,\n            intent.caseId,\n            createdDocId,\n            subject\n          );\n          console.log(\"[onMessageSendHandler] Cached filed email (new doc)\", { conversationId: conversationId.substring(0, 20) + \"...\" });\n        } else {\n          // Fallback: Cache by subject when conversationId not available (new compose emails)\n          await cacheFiledEmailBySubject(\n            subject,\n            intent.caseId,\n            createdDocId\n          );\n          console.log(\"[onMessageSendHandler] Cached filed email by subject (new doc)\", { subject });\n        }\n      }\n    }\n\n    console.log(\"[onMessageSendHandler] Upload successful\");\n    await showInfo(\"SingleCase: email uloen pi odesln.\");\n\n    finish(true);\n  } catch (e) {\n    console.error(\"[onMessageSendHandler] Error during filing\", e);\n\n    try {\n      const msg = e instanceof Error ? e.message : String(e);\n      let errorHint = \"\";\n\n      if (msg.includes(\"timeout\")) errorHint = \" (timeout)\";\n      else if (msg.toLowerCase().includes(\"workspace\")) errorHint = \" (nen nastaven workspace)\";\n      else if (msg.toLowerCase().includes(\"token\")) errorHint = \" (pihlaste se znovu)\";\n      else if (msg.toLowerCase().includes(\"network\")) errorHint = \" (problm se st)\";\n\n      await showInfo(`SingleCase: nepodailo se uloit${errorHint}`);\n    } catch {\n      // ignore\n    }\n\n    finish(true);\n  }\n}","/* global Office */\n\nimport { onMessageSendHandler } from \"./onMessageSendHandler\";\n\nconsole.log(\"[commands.ts] Script loaded\");\n\nlet associated = false;\n\nfunction associateHandlers() {\n  if (associated) return;\n  associated = true;\n\n  try {\n    if (!Office?.actions?.associate) {\n      console.warn(\"[commands.ts] Office.actions.associate not available\");\n      return;\n    }\n\n    console.log(\"[commands.ts] Associating onMessageSendHandler\");\n    Office.actions.associate(\"onMessageSendHandler\", onMessageSendHandler);\n    console.log(\"[commands.ts] Handler associated successfully\");\n  } catch (e) {\n    console.error(\"[commands.ts] Failed to associate handler:\", e);\n  }\n}\n\nasync function boot() {\n  try {\n    if (typeof Office?.onReady === \"function\") {\n      await Office.onReady();\n      console.log(\"[commands.ts] Office.onReady fired\");\n      console.log(\"[commands.ts] Office.context:\", Office.context);\n    } else {\n      console.warn(\"[commands.ts] Office.onReady not available\");\n    }\n  } catch (e) {\n    console.error(\"[commands.ts] Office.onReady failed:\", e);\n  } finally {\n    associateHandlers();\n  }\n}\n\n// Start immediately, but also try again onReady.\n// This avoids cases where the script runs before Office runtime is fully initialised.\nboot();\ntry {\n  if (typeof Office?.onReady === \"function\") {\n    Office.onReady(() => {\n      associateHandlers();\n    });\n  }\n} catch {\n  // ignore\n}"],"names":["module","exports","isFunction","x","isArray","Array","Object","prototype","toString","call","len","vertxNext","customSchedulerFn","asap","callback","arg","queue","flush","scheduleFlush","browserWindow","window","undefined","browserGlobal","BrowserMutationObserver","MutationObserver","WebKitMutationObserver","isNode","self","process","isWorker","Uint8ClampedArray","importScripts","MessageChannel","useSetTimeout","globalSetTimeout","setTimeout","i","channel","iterations","observer","node","then","onFulfillment","onRejection","parent","this","child","constructor","noop","PROMISE_ID","makePromise","_state","arguments","invokeCallback","_result","subscribe","resolve$1","object","promise","resolve","nextTick","document","createTextNode","observe","characterData","data","port1","onmessage","port2","postMessage","vertx","Function","require","runOnLoop","runOnContext","e","attemptVertx","Math","random","substring","PENDING","FULFILLED","REJECTED","handleMaybeThenable","maybeThenable","then$$1","thenable","fulfill","reject","value","reason","handleOwnThenable","sealed","error","fulfillmentHandler","rejectionHandler","tryThen","_label","handleForeignThenable","TypeError","type","publishRejection","_onerror","publish","_subscribers","length","subscribers","settled","detail","hasCallback","succeeded","id","Enumerator","Constructor","input","_instanceConstructor","_remaining","_enumerate","Error","_eachEntry","entry","c","resolve$$1","_then","didError","_settledAt","Promise$1","_willSettleAt","state","enumerator","Promise","resolver","needsResolver","initializePromise","needsNew","catch","finally","all","entries","race","_","_setScheduler","scheduleFn","_setAsap","asapFn","_asap","polyfill","local","g","P","promiseToString","cast","factory","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","globalThis","TOKEN_KEY","USER_KEY","ISSUED_AT_KEY","RT_TOKEN_KEY","RT_USER_KEY","RT_ISSUED_AT_KEY","normalizeEmail","email","v","trim","toLowerCase","rtGet","key","OfficeRuntime","storage","getItem","_b","sent","console","warn","e_1","_a","Office","context","roamingSettings","get","rtRemove","removeItem","getAuthRuntime","token","emailRaw","issuedAtStr","issuedAt","Number","clearAuthIfExpiredRuntime","ageMs","Date","now","clearAuth","sessionStorage","VERBOSE_LOGGING","DEBUG_LOG_KEY","hasOfficeRuntimeStorage","hasRoamingSettings","saveRoamingSettings","startTime","saveAsync","res","duration","status","AsyncResultStatus","Succeeded","errorMsg","message","concat","errorCode","code","errorName","_c","name","getStored","key_1","forceFresh","k","String","storageBackend","shouldLog","log","lsGet","localStorage","v_1","rv","v_2","setStored","value_1","retryCount","MAX_RETRIES","lsSet","setItem","set","saveError_1","includes","remove","_d","settings","dataStore","_data","_settings","_typeof","allKeys","keys","removedCount","_i","allKeys_1","startsWith","_e","_f","raw","blob","JSON","parse","sort","a","b","_savedAt","pruned_1","slice","forEach","stringify","_g","cache","filedAt","pruned_2","_h","emergencyPruneRoamingSettings","retryError_1","delay_1","e_2","STORAGE_KEYS","resolveApiBaseUrl","storedHostRaw","host","replace","split","normalizeHost","baseUrl","encodeURIComponent","getToken","auth","rt","expectJson","errorPrefix","text","ok","statusText","contentType","headers","uploadDocumentVersion","params","documentId","fileName","mimeType","dataBase64","directoryId","base","bodyData","mime_type","data_base64","dir_id","body","candidates","url","method","lastErr","candidates_1","fetch","Authentication","uploadDocumentToCase","caseId","metadata","dataLength","hasToken","tokenPrefix","payload","case_id","documents","documentCount","firstDoc","data_base64_length","e_3","snippet","responseSnippet","json","documentIds","map","d","normalizeSubject","subject","stripPrefixes","normalized","prevLength","findDocumentBySubject","candidates_4","files","items","normalizedSearchSubject","documents_1","doc","filename","endsWith","docSubject","properties","normalizedDocSubject","matches","_id","FILED_CACHE_KEY","cacheFiledEmail","conversationId","caseName","caseKey","platform","mailbox","diagnostics","hostName","hostVersion","keep","newCache_1","val","verification","verifiedCache","writeSuccess","success","cacheSize","writeVerified","cacheFiledEmailBySubject","tempKey","newCache_2","T_FETCH_MS","withTimeout","p","ms","t","clearTimeout","getConversationIdSafe","item","conversationKey","persistFiledCtx","emailDocId","cid","did","convId","getCandidateItemKeysRuntime","hasItemId","itemId","hasConversationId","hasConversationKey","hasDateTimeCreated","dateTimeCreated","hasGetItemIdAsync","getItemIdAsync","itemType","direct","push","asyncId","conv","created","from","Set","filter","Boolean","readIntentAny","itemKeys","itemKeys_1","obj","autoFileOnSend","baseCaseId","baseEmailDocId","itemKey","hasBase","getSubjectRuntime","itemClass","subj","getAsync","getBodyTextRuntime","CoercionType","Text","showInfo","item_1","notificationMessages","replaceAsync","icon","persistent","onMessageSendHandler","event","hasOfficeRuntime","done","finish","allowEvent","errorMessage","hasErrorMessage","completed","_t","storageType","keysToTry","intent","found","foundUnderKey","realItemId","find","to","intentValue","realKey","_j","fallbackKey","_k","e_4","hostRaw","_l","_m","hasSubject","_o","bodyText","itemFrom","_p","fromEmail","emailAddress","_q","userProfile","fromName","displayName","_r","bodyLength","conversationIdPreview","baseName","emailText","toUTCString","emailBase64","bytes","TextEncoder","encode","binary","fromCharCode","btoa","toBase64Utf8","existingDoc","docId","docName","e_5","shouldUploadVersion","existingDocId","existingDocName","conversationId_1","docs","createdDocId","_s","rawResponse","conversationId_2","e_6","msg","errorHint","associated","associateHandlers","actions","associate","onReady","boot"],"ignoreList":[],"sourceRoot":""}