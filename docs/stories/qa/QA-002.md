# QA-002: Frontend Unit Tests

**Story ID:** QA-002
**Story Points:** 5
**Epic Link:** Quality Assurance & Testing
**Status:** Ready for Development

## Description

Implement comprehensive frontend unit testing for all React components, hooks, and UI logic in the Outlook add-in. Use Jest with React Testing Library to test component rendering, user interactions, state management, and accessibility. Focus on testing component behavior and user experience rather than implementation details. Achieve minimum 80% coverage for frontend code.

This story complements QA-001 by focusing on UI components, React hooks, and frontend-specific logic.

## Acceptance Criteria

1. **Testing Framework Setup**
   - React Testing Library configured with Jest
   - Testing utilities for Fluent UI components
   - Custom render function with providers (theme, context)
   - User event simulation library
   - Accessibility testing (jest-axe)

2. **Component Test Coverage (80%+)**
   - MainWorkspace component (case selection, filing)
   - Case selector dropdown/autocomplete
   - Category badge and actions
   - Progress indicators and loading states
   - Error boundary and fallback UI
   - Favorites UI components
   - Settings panel components

3. **Hook Testing**
   - useCaseSuggestions hook (suggestion logic)
   - useEmailCategory hook (category management)
   - useOutlookSuggestions hook (recipient history)
   - Custom hooks with side effects

4. **Interaction Testing**
   - Button clicks and form submissions
   - Dropdown selections and search
   - Keyboard navigation (accessibility)
   - Loading states and spinners
   - Error messages and toasts
   - Modal dialogs and confirmations

5. **Accessibility Testing**
   - ARIA attributes present and correct
   - Keyboard navigation functional
   - Screen reader compatibility
   - Focus management
   - Color contrast (automated check)

6. **Visual Regression Prevention**
   - Snapshot tests for critical UI components
   - Test component output structure
   - Verify conditional rendering logic
   - Test responsive behavior (if applicable)

## Technical Requirements

### Testing Dependencies

1. **Update package.json**
   ```json
   {
     "devDependencies": {
       "@testing-library/react": "^14.2.1",
       "@testing-library/jest-dom": "^6.4.2",
       "@testing-library/user-event": "^14.5.2",
       "jest-axe": "^8.0.0",
       "@fluentui/jest-serializer-merge-styles": "^8.1.0"
     }
   }
   ```

2. **Update setupTests.ts**
   ```typescript
   import '@testing-library/jest-dom';
   import { configure } from '@testing-library/react';
   import { configureAxe } from 'jest-axe';

   // Configure React Testing Library
   configure({ testIdAttribute: 'data-testid' });

   // Configure jest-axe for accessibility testing
   const axe = configureAxe({
     rules: {
       // Customize accessibility rules if needed
       'color-contrast': { enabled: true },
       'label': { enabled: true },
     },
   });

   global.axe = axe;

   // Mock window.matchMedia (for responsive components)
   Object.defineProperty(window, 'matchMedia', {
     writable: true,
     value: jest.fn().mockImplementation((query) => ({
       matches: false,
       media: query,
       onchange: null,
       addListener: jest.fn(),
       removeListener: jest.fn(),
       addEventListener: jest.fn(),
       removeEventListener: jest.fn(),
       dispatchEvent: jest.fn(),
     })),
   });
   ```

### Test Utilities

1. **__tests__/utils/testUtils.tsx**
   ```tsx
   import React, { ReactElement } from 'react';
   import { render, RenderOptions } from '@testing-library/react';
   import { FluentProvider, webLightTheme } from '@fluentui/react-components';

   interface AllProvidersProps {
     children: React.ReactNode;
   }

   function AllProviders({ children }: AllProvidersProps) {
     return (
       <FluentProvider theme={webLightTheme}>
         {children}
       </FluentProvider>
     );
   }

   const customRender = (
     ui: ReactElement,
     options?: Omit<RenderOptions, 'wrapper'>
   ) => render(ui, { wrapper: AllProviders, ...options });

   export * from '@testing-library/react';
   export { customRender as render };
   ```

2. **__tests__/utils/mockData.ts**
   ```typescript
   export const mockCases = [
     {
       id: 'case-1',
       name: 'Project Alpha',
       client: 'ACME Corp',
       status: 'active',
       isFavorite: false,
     },
     {
       id: 'case-2',
       name: 'Project Beta',
       client: 'TechCo',
       status: 'active',
       isFavorite: true,
     },
   ];

   export const mockSuggestions = [
     {
       caseId: 'case-1',
       caseName: 'Project Alpha',
       score: 0.85,
       reason: 'Email domain match',
     },
   ];

   export const mockUser = {
     email: 'user@example.com',
     name: 'Test User',
   };
   ```

### Component Tests

1. **components/MainWorkspace/MainWorkspace.test.tsx**
   ```tsx
   import React from 'react';
   import { render, screen, waitFor } from '@/tests/utils/testUtils';
   import userEvent from '@testing-library/user-event';
   import { MainWorkspace } from './MainWorkspace';
   import * as singlecaseService from '@/services/singlecase';

   jest.mock('@/services/singlecase');
   jest.mock('@/services/auth');

   describe('MainWorkspace Component', () => {
     beforeEach(() => {
       jest.clearAllMocks();
     });

     test('renders main workspace with case selector', () => {
       render(<MainWorkspace />);

       expect(screen.getByText(/select a case/i)).toBeInTheDocument();
       expect(screen.getByRole('combobox')).toBeInTheDocument();
     });

     test('displays loading state while fetching cases', () => {
       (singlecaseService.getCases as jest.Mock).mockReturnValue(
         new Promise(() => {}) // Never resolves
       );

       render(<MainWorkspace />);

       expect(screen.getByRole('progressbar')).toBeInTheDocument();
       expect(screen.getByText(/loading cases/i)).toBeInTheDocument();
     });

     test('displays error message when case loading fails', async () => {
       (singlecaseService.getCases as jest.Mock).mockRejectedValue(
         new Error('Network error')
       );

       render(<MainWorkspace />);

       await waitFor(() => {
         expect(screen.getByText(/failed to load cases/i)).toBeInTheDocument();
       });
     });

     test('displays case list when loaded successfully', async () => {
       (singlecaseService.getCases as jest.Mock).mockResolvedValue([
         { id: '1', name: 'Case 1', client: 'Client A' },
         { id: '2', name: 'Case 2', client: 'Client B' },
       ]);

       render(<MainWorkspace />);

       await waitFor(() => {
         expect(screen.getByText('Case 1')).toBeInTheDocument();
         expect(screen.getByText('Case 2')).toBeInTheDocument();
       });
     });

     test('allows user to select a case', async () => {
       const user = userEvent.setup();
       (singlecaseService.getCases as jest.Mock).mockResolvedValue([
         { id: '1', name: 'Case 1', client: 'Client A' },
       ]);

       render(<MainWorkspace />);

       await waitFor(() => {
         expect(screen.getByText('Case 1')).toBeInTheDocument();
       });

       const caseOption = screen.getByText('Case 1');
       await user.click(caseOption);

       expect(screen.getByText(/file email to case 1/i)).toBeInTheDocument();
     });

     test('files email when File button clicked', async () => {
       const user = userEvent.setup();
       (singlecaseService.getCases as jest.Mock).mockResolvedValue([
         { id: '1', name: 'Case 1', client: 'Client A' },
       ]);
       (singlecaseService.fileEmail as jest.Mock).mockResolvedValue({
         success: true,
         linkId: 'link-123',
       });

       render(<MainWorkspace />);

       await waitFor(() => {
         expect(screen.getByText('Case 1')).toBeInTheDocument();
       });

       await user.click(screen.getByText('Case 1'));
       await user.click(screen.getByRole('button', { name: /file email/i }));

       await waitFor(() => {
         expect(singlecaseService.fileEmail).toHaveBeenCalledWith(
           expect.objectContaining({ caseId: '1' })
         );
         expect(screen.getByText(/email filed successfully/i)).toBeInTheDocument();
       });
     });

     test('disables File button during filing operation', async () => {
       const user = userEvent.setup();
       (singlecaseService.fileEmail as jest.Mock).mockReturnValue(
         new Promise(() => {}) // Never resolves
       );

       render(<MainWorkspace />);

       const fileButton = screen.getByRole('button', { name: /file email/i });
       await user.click(fileButton);

       expect(fileButton).toBeDisabled();
       expect(screen.getByText(/filing.../i)).toBeInTheDocument();
     });
   });
   ```

2. **components/CaseSelector/CaseSelector.test.tsx**
   ```tsx
   import React from 'react';
   import { render, screen, within } from '@/tests/utils/testUtils';
   import userEvent from '@testing-library/user-event';
   import { CaseSelector } from './CaseSelector';
   import { mockCases } from '@/tests/utils/mockData';

   describe('CaseSelector Component', () => {
     const mockOnSelect = jest.fn();

     beforeEach(() => {
       jest.clearAllMocks();
     });

     test('renders dropdown with cases', () => {
       render(
         <CaseSelector
           cases={mockCases}
           selectedCaseId={null}
           onSelect={mockOnSelect}
         />
       );

       expect(screen.getByRole('combobox')).toBeInTheDocument();
       expect(screen.getByPlaceholderText(/search cases/i)).toBeInTheDocument();
     });

     test('displays favorite cases at the top', async () => {
       const user = userEvent.setup();
       render(
         <CaseSelector
           cases={mockCases}
           selectedCaseId={null}
           onSelect={mockOnSelect}
         />
       );

       // Open dropdown
       await user.click(screen.getByRole('combobox'));

       const options = screen.getAllByRole('option');
       expect(within(options[0]).getByText(/project beta/i)).toBeInTheDocument();
       expect(within(options[0]).getByLabelText(/favorite/i)).toBeInTheDocument();
     });

     test('filters cases when typing in search', async () => {
       const user = userEvent.setup();
       render(
         <CaseSelector
           cases={mockCases}
           selectedCaseId={null}
           onSelect={mockOnSelect}
         />
       );

       const input = screen.getByRole('combobox');
       await user.type(input, 'alpha');

       expect(screen.getByText('Project Alpha')).toBeInTheDocument();
       expect(screen.queryByText('Project Beta')).not.toBeInTheDocument();
     });

     test('calls onSelect when case is selected', async () => {
       const user = userEvent.setup();
       render(
         <CaseSelector
           cases={mockCases}
           selectedCaseId={null}
           onSelect={mockOnSelect}
         />
       );

       await user.click(screen.getByRole('combobox'));
       await user.click(screen.getByText('Project Alpha'));

       expect(mockOnSelect).toHaveBeenCalledWith('case-1');
     });

     test('displays selected case', () => {
       render(
         <CaseSelector
           cases={mockCases}
           selectedCaseId="case-1"
           onSelect={mockOnSelect}
         />
       );

       expect(screen.getByDisplayValue('Project Alpha')).toBeInTheDocument();
     });

     test('shows "No cases found" when search has no results', async () => {
       const user = userEvent.setup();
       render(
         <CaseSelector
           cases={mockCases}
           selectedCaseId={null}
           onSelect={mockOnSelect}
         />
       );

       await user.type(screen.getByRole('combobox'), 'nonexistent');

       expect(screen.getByText(/no cases found/i)).toBeInTheDocument();
     });
   });
   ```

3. **components/CategoryBadge/CategoryBadge.test.tsx**
   ```tsx
   import React from 'react';
   import { render, screen } from '@/tests/utils/testUtils';
   import { CategoryBadge } from './CategoryBadge';

   describe('CategoryBadge Component', () => {
     test('renders filed status badge', () => {
       render(<CategoryBadge status="filed" />);

       const badge = screen.getByText(/filed/i);
       expect(badge).toBeInTheDocument();
       expect(badge).toHaveClass('success'); // Green color
     });

     test('renders unfiled status badge', () => {
       render(<CategoryBadge status="unfiled" />);

       const badge = screen.getByText(/unfiled/i);
       expect(badge).toBeInTheDocument();
       expect(badge).toHaveClass('warning'); // Orange color
     });

     test('renders no category badge', () => {
       render(<CategoryBadge status="none" />);

       const badge = screen.getByText(/no category/i);
       expect(badge).toBeInTheDocument();
       expect(badge).toHaveClass('neutral'); // Gray color
     });

     test('calls onClick when badge is clicked', async () => {
       const mockOnClick = jest.fn();
       const user = userEvent.setup();

       render(<CategoryBadge status="filed" onClick={mockOnClick} />);

       await user.click(screen.getByText(/filed/i));

       expect(mockOnClick).toHaveBeenCalledTimes(1);
     });

     test('is not clickable when onClick is not provided', () => {
       render(<CategoryBadge status="filed" />);

       const badge = screen.getByText(/filed/i);
       expect(badge).not.toHaveAttribute('role', 'button');
     });
   });
   ```

### Hook Tests

1. **hooks/useCaseSuggestions.test.tsx**
   ```tsx
   import { renderHook, waitFor } from '@testing-library/react';
   import { useCaseSuggestions } from './useCaseSuggestions';
   import * as suggestionEngine from '@/utils/caseSuggestionEngine';

   jest.mock('@/utils/caseSuggestionEngine');

   describe('useCaseSuggestions Hook', () => {
     const mockCases = [
       { id: '1', name: 'Case 1', client: 'Client A' },
       { id: '2', name: 'Case 2', client: 'Client B' },
     ];

     beforeEach(() => {
       jest.clearAllMocks();
     });

     test('returns suggestions when email context available', async () => {
       (suggestionEngine.generateCaseSuggestions as jest.Mock).mockReturnValue([
         { caseId: '1', score: 0.85, reason: 'Domain match' },
       ]);

       const { result } = renderHook(() =>
         useCaseSuggestions(mockCases, {
           from: 'user@clienta.com',
           subject: 'Test',
         })
       );

       await waitFor(() => {
         expect(result.current.suggestions).toHaveLength(1);
         expect(result.current.suggestions[0].caseId).toBe('1');
       });
     });

     test('returns empty array when no suggestions', async () => {
       (suggestionEngine.generateCaseSuggestions as jest.Mock).mockReturnValue([]);

       const { result } = renderHook(() =>
         useCaseSuggestions(mockCases, {
           from: 'unknown@example.com',
           subject: 'Test',
         })
       );

       await waitFor(() => {
         expect(result.current.suggestions).toHaveLength(0);
       });
     });

     test('updates suggestions when cases change', async () => {
       (suggestionEngine.generateCaseSuggestions as jest.Mock).mockReturnValue([
         { caseId: '1', score: 0.85, reason: 'Match' },
       ]);

       const { result, rerender } = renderHook(
         ({ cases }) => useCaseSuggestions(cases, { from: 'user@example.com' }),
         { initialProps: { cases: mockCases } }
       );

       await waitFor(() => {
         expect(result.current.suggestions).toHaveLength(1);
       });

       // Add new case
       const newCases = [...mockCases, { id: '3', name: 'Case 3', client: 'Client C' }];
       (suggestionEngine.generateCaseSuggestions as jest.Mock).mockReturnValue([
         { caseId: '3', score: 0.90, reason: 'Better match' },
       ]);

       rerender({ cases: newCases });

       await waitFor(() => {
         expect(result.current.suggestions[0].caseId).toBe('3');
       });
     });
   });
   ```

2. **hooks/useEmailCategory.test.tsx**
   ```tsx
   import { renderHook, act, waitFor } from '@testing-library/react';
   import { useEmailCategory } from './useEmailCategory';
   import * as categoryManager from '@/services/categoryManager';

   jest.mock('@/services/categoryManager');

   describe('useEmailCategory Hook', () => {
     beforeEach(() => {
       jest.clearAllMocks();
     });

     test('loads current category status on mount', async () => {
       (categoryManager.getCurrentCategoryStatus as jest.Mock).mockResolvedValue(
         'filed'
       );

       const { result } = renderHook(() => useEmailCategory());

       expect(result.current.isLoading).toBe(true);

       await waitFor(() => {
         expect(result.current.status).toBe('filed');
         expect(result.current.isLoading).toBe(false);
       });
     });

     test('applies filed category successfully', async () => {
       (categoryManager.getCurrentCategoryStatus as jest.Mock).mockResolvedValue('none');
       (categoryManager.applyCategoryWithFallback as jest.Mock).mockResolvedValue({
         success: true,
         method: 'office-js',
       });

       const { result } = renderHook(() => useEmailCategory());

       await waitFor(() => {
         expect(result.current.isLoading).toBe(false);
       });

       await act(async () => {
         await result.current.applyFiled();
       });

       await waitFor(() => {
         expect(categoryManager.applyCategoryWithFallback).toHaveBeenCalledWith('filed');
         expect(result.current.status).toBe('filed');
       });
     });

     test('handles category application error', async () => {
       (categoryManager.getCurrentCategoryStatus as jest.Mock).mockResolvedValue('none');
       (categoryManager.applyCategoryWithFallback as jest.Mock).mockRejectedValue(
         new Error('Failed to apply category')
       );

       const { result } = renderHook(() => useEmailCategory());

       await waitFor(() => {
         expect(result.current.isLoading).toBe(false);
       });

       await act(async () => {
         await result.current.applyFiled();
       });

       await waitFor(() => {
         expect(result.current.error).toBeTruthy();
         expect(result.current.error?.message).toContain('Failed to apply category');
       });
     });

     test('refreshes category status', async () => {
       (categoryManager.getCurrentCategoryStatus as jest.Mock)
         .mockResolvedValueOnce('none')
         .mockResolvedValueOnce('filed');

       const { result } = renderHook(() => useEmailCategory());

       await waitFor(() => {
         expect(result.current.status).toBe('none');
       });

       await act(async () => {
         await result.current.refresh();
       });

       await waitFor(() => {
         expect(result.current.status).toBe('filed');
       });
     });
   });
   ```

### Accessibility Tests

1. **components/MainWorkspace/MainWorkspace.a11y.test.tsx**
   ```tsx
   import React from 'react';
   import { render } from '@/tests/utils/testUtils';
   import { axe, toHaveNoViolations } from 'jest-axe';
   import { MainWorkspace } from './MainWorkspace';

   expect.extend(toHaveNoViolations);

   describe('MainWorkspace Accessibility', () => {
     test('should not have accessibility violations', async () => {
       const { container } = render(<MainWorkspace />);

       const results = await axe(container);

       expect(results).toHaveNoViolations();
     });

     test('has proper ARIA labels', () => {
       const { getByLabelText } = render(<MainWorkspace />);

       expect(getByLabelText(/select a case/i)).toBeInTheDocument();
       expect(getByLabelText(/file email/i)).toBeInTheDocument();
     });

     test('supports keyboard navigation', async () => {
       const { getByRole } = render(<MainWorkspace />);
       const caseSelector = getByRole('combobox');

       // Should be focusable
       caseSelector.focus();
       expect(caseSelector).toHaveFocus();

       // Tab to next element
       userEvent.tab();
       expect(getByRole('button', { name: /file email/i })).toHaveFocus();
     });
   });
   ```

### Snapshot Tests

1. **components/CategoryBadge/CategoryBadge.snapshot.test.tsx**
   ```tsx
   import React from 'react';
   import { render } from '@/tests/utils/testUtils';
   import { CategoryBadge } from './CategoryBadge';

   describe('CategoryBadge Snapshots', () => {
     test('matches snapshot for filed status', () => {
       const { container } = render(<CategoryBadge status="filed" />);
       expect(container.firstChild).toMatchSnapshot();
     });

     test('matches snapshot for unfiled status', () => {
       const { container } = render(<CategoryBadge status="unfiled" />);
       expect(container.firstChild).toMatchSnapshot();
     });

     test('matches snapshot for no category', () => {
       const { container } = render(<CategoryBadge status="none" />);
       expect(container.firstChild).toMatchSnapshot();
     });
   });
   ```

## Testing Patterns

### User Event Testing
```tsx
import userEvent from '@testing-library/user-event';

test('user can interact with component', async () => {
  const user = userEvent.setup();
  render(<MyComponent />);

  await user.click(screen.getByRole('button'));
  await user.type(screen.getByRole('textbox'), 'test input');
  await user.keyboard('{Enter}');
});
```

### Async Testing
```tsx
test('handles async operations', async () => {
  render(<AsyncComponent />);

  await waitFor(() => {
    expect(screen.getByText('Loaded')).toBeInTheDocument();
  });
});
```

### Error Boundary Testing
```tsx
test('error boundary catches errors', () => {
  const ThrowError = () => {
    throw new Error('Test error');
  };

  render(
    <ErrorBoundary>
      <ThrowError />
    </ErrorBoundary>
  );

  expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
});
```

## Dependencies

- **Depends on**: QA-001 (Backend Tests) - provides service mocks
- **Required for**: QA-003 (E2E Tests) - validates component integration
- **Required for**: QA-006 (UAT Execution) - UI confidence
- **Enhances**: Component maintainability and regression prevention

## Notes

1. **Testing Philosophy**
   - Test behavior, not implementation
   - Query by accessible role/label (getByRole, getByLabelText)
   - Avoid testing internal state directly
   - Test from user's perspective

2. **Fluent UI Testing**
   - Use Fluent UI test utilities if available
   - Mock theme provider in tests
   - Test component appearance in light/dark themes
   - Verify Fluent UI component props

3. **Performance Testing**
   - Use `@testing-library/react` cleanup
   - Avoid excessive snapshot tests (slow)
   - Mock expensive operations (API calls)
   - Run tests in parallel

4. **Common Pitfalls**
   - Don't use `container.querySelector` (not accessible)
   - Don't test implementation details (state, props)
   - Don't forget to await async operations
   - Don't forget to cleanup side effects

5. **Coverage Goals**
   - 80%+ line coverage for components
   - 100% coverage for critical paths (filing, auth)
   - Lower priority for pure UI components
   - Focus on logic-heavy components first

## Definition of Done

- [ ] React Testing Library configured
- [ ] Test utilities and custom render function created
- [ ] Mock data factories created
- [ ] MainWorkspace component fully tested
- [ ] CaseSelector component fully tested
- [ ] CategoryBadge component fully tested
- [ ] Progress indicators tested
- [ ] Error boundary tested
- [ ] useCaseSuggestions hook tested
- [ ] useEmailCategory hook tested
- [ ] useOutlookSuggestions hook tested
- [ ] Accessibility tests implemented (jest-axe)
- [ ] Keyboard navigation tested
- [ ] User interaction tests completed
- [ ] Snapshot tests for critical components
- [ ] Code coverage at 80%+ for frontend
- [ ] All tests passing
- [ ] Test documentation added to README
