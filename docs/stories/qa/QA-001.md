# QA-001: Backend Unit & Integration Tests

**Story ID:** QA-001
**Story Points:** 8
**Epic Link:** Quality Assurance & Testing
**Status:** Ready for Development

## Description

Establish comprehensive backend unit and integration testing infrastructure for all API services, utilities, and data management modules in the Outlook add-in. Implement Jest as the primary testing framework with coverage tracking, mocking strategies for Office.js APIs, MSAL authentication, and external API calls. Achieve minimum 80% code coverage across all backend TypeScript modules.

This story focuses on testing the core business logic, API integrations (SingleCase, Graph API), authentication flows, storage utilities, and data transformation logic.

## Acceptance Criteria

1. **Testing Framework Setup**
   - Jest configured with TypeScript support (ts-jest)
   - Test runner configured for Node.js environment
   - Coverage reporting with Istanbul/NYC (80%+ threshold)
   - Test watch mode for development
   - Parallel test execution for performance

2. **Unit Test Coverage (80%+)**
   - All services: `services/*.ts` (auth, cases, client, singlecase, graphMail, diagnostics, singlecaseDocuments)
   - All utilities: `utils/*.ts` (storage, cache, suggestion engine, validation)
   - All hooks: `hooks/*.ts` (business logic extraction)
   - Command handlers: `commands/*.ts` (onMessageSendHandler, commands)

3. **Integration Tests**
   - API client integration (services/client.ts with mock responses)
   - Authentication flow (MSAL token acquisition, refresh)
   - Storage integration (localStorage/Office settings)
   - Case suggestion engine (end-to-end logic)
   - Filing workflow (idempotent filing logic)

4. **Mocking Strategy**
   - Office.js APIs mocked (Office.context.mailbox.*)
   - MSAL Browser API mocked (@azure/msal-browser)
   - Fetch API mocked (API requests)
   - LocalStorage/sessionStorage mocked
   - Date/Time mocked for consistent test results

5. **Test Organization**
   - Test files colocated with source: `*.test.ts` or `__tests__/` folder
   - Test naming convention: `describe('ModuleName', () => { test('should...') })`
   - Setup/teardown in `beforeEach`/`afterEach` hooks
   - Test data factories for reusable fixtures

6. **CI/CD Integration**
   - Tests run automatically on `npm test`
   - Coverage report generated in `coverage/` directory
   - Tests pass before allowing builds
   - Coverage thresholds enforced (fail build if below 80%)

## Technical Requirements

### Jest Configuration

1. **jest.config.js** (create at project root)
   ```javascript
   module.exports = {
     preset: 'ts-jest',
     testEnvironment: 'jsdom', // For Office.js DOM APIs
     roots: ['<rootDir>/src'],
     testMatch: [
       '**/__tests__/**/*.ts?(x)',
       '**/?(*.)+(spec|test).ts?(x)',
     ],
     moduleNameMapper: {
       // Handle CSS imports (mock)
       '\\.(css|less)$': '<rootDir>/__mocks__/styleMock.js',
       // Handle image imports (mock)
       '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/__mocks__/fileMock.js',
       // Path aliases (match webpack config)
       '^@/(.*)$': '<rootDir>/src/$1',
     },
     setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
     collectCoverageFrom: [
       'src/**/*.{ts,tsx}',
       '!src/**/*.d.ts',
       '!src/**/*.test.{ts,tsx}',
       '!src/**/__tests__/**',
       '!src/taskpane/index.tsx', // Entry point
       '!src/commands/commands.runtime.ts', // Runtime file
     ],
     coverageThreshold: {
       global: {
         branches: 80,
         functions: 80,
         lines: 80,
         statements: 80,
       },
     },
     coverageReporters: ['text', 'lcov', 'html', 'json-summary'],
     transform: {
       '^.+\\.tsx?$': ['ts-jest', {
         tsconfig: {
           jsx: 'react',
           esModuleInterop: true,
           allowSyntheticDefaultImports: true,
         },
       }],
     },
     globals: {
       Office: {},
       OfficeRuntime: {},
     },
   };
   ```

2. **Update package.json scripts**
   ```json
   {
     "scripts": {
       "test": "jest",
       "test:watch": "jest --watch",
       "test:coverage": "jest --coverage",
       "test:ci": "jest --ci --coverage --maxWorkers=2"
     },
     "devDependencies": {
       "@types/jest": "^29.5.12",
       "jest": "^29.7.0",
       "jest-environment-jsdom": "^29.7.0",
       "ts-jest": "^29.1.2"
     }
   }
   ```

3. **src/setupTests.ts** (test setup file)
   ```typescript
   // Mock Office.js global
   global.Office = {
     context: {
       mailbox: {
         item: {
           itemId: 'test-item-id',
           subject: 'Test Subject',
           from: { emailAddress: 'sender@example.com' },
           to: [{ emailAddress: 'recipient@example.com' }],
           categories: {
             getAsync: jest.fn(),
             addAsync: jest.fn(),
             removeAsync: jest.fn(),
           },
         },
         userProfile: {
           emailAddress: 'user@example.com',
         },
       },
       roamingSettings: {
         get: jest.fn(),
         set: jest.fn(),
         saveAsync: jest.fn(),
       },
     },
     AsyncResultStatus: {
       Succeeded: 'succeeded',
       Failed: 'failed',
     },
     MailboxEnums: {
       CategoryColor: {
         Preset4: 'preset4',
         Preset7: 'preset7',
       },
     },
   } as any;

   global.OfficeRuntime = {
     auth: {
       getAccessToken: jest.fn(),
     },
     storage: {
       getItem: jest.fn(),
       setItem: jest.fn(),
       removeItem: jest.fn(),
     },
   } as any;

   // Mock fetch
   global.fetch = jest.fn();

   // Mock localStorage
   const localStorageMock = {
     getItem: jest.fn(),
     setItem: jest.fn(),
     removeItem: jest.fn(),
     clear: jest.fn(),
   };
   global.localStorage = localStorageMock as any;
   ```

### Unit Tests - Services

1. **services/auth.test.ts**
   ```typescript
   import { getAccessToken, isAuthenticated, refreshToken } from './auth';
   import { PublicClientApplication } from '@azure/msal-browser';

   jest.mock('@azure/msal-browser');

   describe('Authentication Service', () => {
     let mockPCA: jest.Mocked<PublicClientApplication>;

     beforeEach(() => {
       jest.clearAllMocks();
       mockPCA = new PublicClientApplication({} as any) as any;
     });

     describe('getAccessToken', () => {
       test('should return token from silent authentication', async () => {
         mockPCA.acquireTokenSilent = jest.fn().mockResolvedValue({
           accessToken: 'mock-token-123',
           expiresOn: new Date(Date.now() + 3600000),
         });

         const token = await getAccessToken();

         expect(token).toBe('mock-token-123');
         expect(mockPCA.acquireTokenSilent).toHaveBeenCalled();
       });

       test('should fallback to popup when silent fails', async () => {
         mockPCA.acquireTokenSilent = jest.fn().mockRejectedValue(
           new Error('Interaction required')
         );
         mockPCA.acquireTokenPopup = jest.fn().mockResolvedValue({
           accessToken: 'popup-token-456',
         });

         const token = await getAccessToken();

         expect(token).toBe('popup-token-456');
         expect(mockPCA.acquireTokenPopup).toHaveBeenCalled();
       });

       test('should throw error when both methods fail', async () => {
         mockPCA.acquireTokenSilent = jest.fn().mockRejectedValue(
           new Error('Silent failed')
         );
         mockPCA.acquireTokenPopup = jest.fn().mockRejectedValue(
           new Error('Popup failed')
         );

         await expect(getAccessToken()).rejects.toThrow();
       });
     });

     describe('isAuthenticated', () => {
       test('should return true when account exists', () => {
         mockPCA.getAllAccounts = jest.fn().mockReturnValue([
           { username: 'user@example.com' },
         ]);

         expect(isAuthenticated()).toBe(true);
       });

       test('should return false when no accounts exist', () => {
         mockPCA.getAllAccounts = jest.fn().mockReturnValue([]);

         expect(isAuthenticated()).toBe(false);
       });
     });
   });
   ```

2. **services/singlecase.test.ts**
   ```typescript
   import { getCases, fileEmail, resolveBaseUrl } from './singlecase';
   import { getStored, setStored } from '../utils/storage';

   jest.mock('../utils/storage');
   jest.mock('./auth');

   describe('SingleCase Service', () => {
     beforeEach(() => {
       jest.clearAllMocks();
       (global.fetch as jest.Mock).mockClear();
     });

     describe('resolveBaseUrl', () => {
       test('should construct proxy URL with workspace host', async () => {
         (getStored as jest.Mock).mockResolvedValue('customer1.singlecase.ch');

         const url = await resolveBaseUrl();

         expect(url).toBe('/singlecase/customer1.singlecase.ch/publicapi/v1');
       });

       test('should throw error when workspace host is missing', async () => {
         (getStored as jest.Mock).mockResolvedValue(null);

         await expect(resolveBaseUrl()).rejects.toThrow('Workspace host is missing');
       });
     });

     describe('getCases', () => {
       test('should fetch cases from API', async () => {
         (getStored as jest.Mock).mockResolvedValue('customer1.singlecase.ch');
         (global.fetch as jest.Mock).mockResolvedValue({
           ok: true,
           json: async () => ({
             cases: [
               { id: '1', name: 'Case 1', client: 'Client A' },
               { id: '2', name: 'Case 2', client: 'Client B' },
             ],
           }),
         });

         const cases = await getCases('mock-token');

         expect(cases).toHaveLength(2);
         expect(cases[0].name).toBe('Case 1');
         expect(global.fetch).toHaveBeenCalledWith(
           expect.stringContaining('/publicapi/v1/cases'),
           expect.objectContaining({
             headers: expect.objectContaining({
               Authentication: 'mock-token',
             }),
           })
         );
       });

       test('should handle API errors', async () => {
         (getStored as jest.Mock).mockResolvedValue('customer1.singlecase.ch');
         (global.fetch as jest.Mock).mockResolvedValue({
           ok: false,
           status: 401,
           statusText: 'Unauthorized',
         });

         await expect(getCases('invalid-token')).rejects.toThrow();
       });
     });

     describe('fileEmail', () => {
       test('should file email successfully', async () => {
         (getStored as jest.Mock).mockResolvedValue('customer1.singlecase.ch');
         (global.fetch as jest.Mock).mockResolvedValue({
           ok: true,
           json: async () => ({ linkId: 'link-123' }),
         });

         const result = await fileEmail({
           caseId: 'case-1',
           itemId: 'item-abc',
           token: 'mock-token',
         });

         expect(result.linkId).toBe('link-123');
         expect(global.fetch).toHaveBeenCalledWith(
           expect.stringContaining('/cases/case-1/links'),
           expect.objectContaining({
             method: 'POST',
           })
         );
       });
     });
   });
   ```

3. **utils/caseSuggestionEngine.test.ts**
   ```typescript
   import {
     generateCaseSuggestions,
     scoreCaseSuggestion,
     extractEmailDomain,
   } from './caseSuggestionEngine';

   describe('Case Suggestion Engine', () => {
     const mockCases = [
       {
         id: '1',
         name: 'Project Alpha',
         client: 'ACME Corp',
         participants: ['john@acme.com', 'jane@acme.com'],
       },
       {
         id: '2',
         name: 'Project Beta',
         client: 'TechCo',
         participants: ['bob@techco.com'],
       },
     ];

     describe('generateCaseSuggestions', () => {
       test('should suggest case based on email domain match', () => {
         const emailContext = {
           from: 'john@acme.com',
           to: ['user@example.com'],
           subject: 'Meeting notes',
         };

         const suggestions = generateCaseSuggestions(mockCases, emailContext);

         expect(suggestions[0].caseId).toBe('1');
         expect(suggestions[0].score).toBeGreaterThan(0.5);
         expect(suggestions[0].reason).toContain('domain match');
       });

       test('should suggest case based on subject keywords', () => {
         const emailContext = {
           from: 'external@example.com',
           to: ['user@example.com'],
           subject: 'Re: Project Alpha deliverables',
         };

         const suggestions = generateCaseSuggestions(mockCases, emailContext);

         expect(suggestions[0].caseId).toBe('1');
         expect(suggestions[0].reason).toContain('subject match');
       });

       test('should return empty array when no matches', () => {
         const emailContext = {
           from: 'unknown@example.com',
           to: ['user@example.com'],
           subject: 'Random topic',
         };

         const suggestions = generateCaseSuggestions(mockCases, emailContext);

         expect(suggestions).toHaveLength(0);
       });
     });

     describe('extractEmailDomain', () => {
       test('should extract domain from email', () => {
         expect(extractEmailDomain('user@example.com')).toBe('example.com');
       });

       test('should handle invalid emails', () => {
         expect(extractEmailDomain('invalid')).toBe('');
         expect(extractEmailDomain('')).toBe('');
       });
     });
   });
   ```

4. **utils/storage.test.ts**
   ```typescript
   import { getStored, setStored, removeStored } from './storage';

   describe('Storage Utility', () => {
     beforeEach(() => {
       jest.clearAllMocks();
     });

     describe('getStored', () => {
       test('should retrieve from Office settings first', async () => {
         const mockGet = jest.fn().mockReturnValue('office-value');
         global.Office.context.roamingSettings.get = mockGet;

         const value = await getStored('testKey');

         expect(value).toBe('office-value');
         expect(mockGet).toHaveBeenCalledWith('testKey');
       });

       test('should fallback to localStorage when Office unavailable', async () => {
         global.Office = undefined as any;
         (global.localStorage.getItem as jest.Mock).mockReturnValue(
           JSON.stringify('local-value')
         );

         const value = await getStored('testKey');

         expect(value).toBe('local-value');
       });

       test('should return null when key not found', async () => {
         global.Office.context.roamingSettings.get = jest.fn().mockReturnValue(undefined);

         const value = await getStored('nonexistent');

         expect(value).toBeNull();
       });
     });

     describe('setStored', () => {
       test('should save to Office settings and persist', async () => {
         const mockSet = jest.fn();
         const mockSaveAsync = jest.fn((callback) =>
           callback({ status: Office.AsyncResultStatus.Succeeded })
         );
         global.Office.context.roamingSettings.set = mockSet;
         global.Office.context.roamingSettings.saveAsync = mockSaveAsync;

         await setStored('testKey', 'testValue');

         expect(mockSet).toHaveBeenCalledWith('testKey', 'testValue');
         expect(mockSaveAsync).toHaveBeenCalled();
       });
     });
   });
   ```

### Integration Tests

1. **integration/filingWorkflow.test.ts**
   ```typescript
   import { fileEmailToCase } from '../services/singlecase';
   import { applyFiledCategory } from '../services/graphMail';
   import { getAccessToken } from '../services/auth';

   describe('Filing Workflow Integration', () => {
     test('should complete full filing workflow', async () => {
       // Mock all dependencies
       (getAccessToken as jest.Mock).mockResolvedValue('mock-token');
       (global.fetch as jest.Mock).mockResolvedValue({
         ok: true,
         json: async () => ({ linkId: 'link-123' }),
       });

       // Execute workflow
       const result = await fileEmailToCase({
         caseId: 'case-1',
         itemId: 'item-abc',
       });

       expect(result.success).toBe(true);
       expect(result.linkId).toBe('link-123');

       // Verify category application attempted
       expect(applyFiledCategory).toHaveBeenCalled();
     });
   });
   ```

2. **integration/authenticationFlow.test.ts**
   ```typescript
   import { msalInstance, initializeMsal, getAccessToken } from '../services/auth';

   describe('Authentication Flow Integration', () => {
     test('should initialize MSAL and acquire token', async () => {
       await initializeMsal();

       expect(msalInstance).toBeDefined();

       const token = await getAccessToken();

       expect(token).toBeTruthy();
       expect(typeof token).toBe('string');
     });
   });
   ```

### Test Data Factories

1. **__tests__/factories/caseFactory.ts**
   ```typescript
   export function createMockCase(overrides = {}) {
     return {
       id: 'case-1',
       name: 'Test Case',
       client: 'Test Client',
       status: 'active',
       participants: ['user@example.com'],
       createdAt: new Date('2024-01-01'),
       ...overrides,
     };
   }

   export function createMockCaseList(count = 3) {
     return Array.from({ length: count }, (_, i) =>
       createMockCase({ id: `case-${i + 1}`, name: `Case ${i + 1}` })
     );
   }
   ```

2. **__tests__/factories/emailFactory.ts**
   ```typescript
   export function createMockEmailContext(overrides = {}) {
     return {
       itemId: 'item-123',
       subject: 'Test Email',
       from: 'sender@example.com',
       to: ['recipient@example.com'],
       cc: [],
       date: new Date(),
       ...overrides,
     };
   }
   ```

### Mock Files

1. **__mocks__/styleMock.js**
   ```javascript
   module.exports = {};
   ```

2. **__mocks__/fileMock.js**
   ```javascript
   module.exports = 'test-file-stub';
   ```

## Test Coverage Requirements

### Critical Path Coverage (90%+)
- Authentication flows (MSAL, Office SSO)
- API client (fetch wrapper, error handling)
- Filing workflow (idempotent filing logic)
- Case suggestion engine (scoring algorithm)
- Storage utilities (Office settings, localStorage)

### Standard Coverage (80%+)
- All service modules (services/*.ts)
- All utility modules (utils/*.ts)
- All hook business logic (hooks/*.ts)
- Command handlers (commands/*.ts)

### Excluded from Coverage
- Type definitions (*.d.ts)
- Entry points (index.tsx, commands.runtime.ts)
- Pure UI components (tested in QA-002)
- External library wrappers (minimal logic)

## Testing Best Practices

1. **Test Naming Convention**
   - Use descriptive test names: "should [expected behavior] when [condition]"
   - Group related tests with `describe` blocks
   - Use `test` or `it` for individual test cases

2. **Arrange-Act-Assert Pattern**
   ```typescript
   test('should file email successfully', async () => {
     // Arrange
     const mockCase = createMockCase();
     const mockEmail = createMockEmailContext();

     // Act
     const result = await fileEmail(mockCase.id, mockEmail.itemId);

     // Assert
     expect(result.success).toBe(true);
   });
   ```

3. **Mock Management**
   - Clear mocks in `beforeEach` hook
   - Use `jest.resetAllMocks()` or `jest.clearAllMocks()`
   - Verify mock calls with `expect().toHaveBeenCalledWith()`

4. **Async Testing**
   - Use `async/await` for asynchronous tests
   - Use `expect().rejects.toThrow()` for error cases
   - Set appropriate test timeouts for slow operations

5. **Test Isolation**
   - Each test should be independent
   - No shared state between tests
   - Clean up resources in `afterEach` hooks

## Dependencies

- **Required for**: QA-003 (E2E Tests) - unit tests validate component logic
- **Required for**: QA-006 (UAT Execution) - confidence in core functionality
- **Blocks**: Production deployment if coverage below 80%
- **Enhances**: Code maintainability and regression prevention

## Notes

1. **Office.js Testing Challenges**
   - Office.js APIs only available in Outlook runtime
   - Mock Office global object in test setup
   - Test logic separately from Office.js calls
   - Use dependency injection for testability

2. **MSAL Testing**
   - Mock PublicClientApplication class
   - Test token acquisition flows (silent, popup, redirect)
   - Test token refresh logic
   - Test error handling (interaction required, network errors)

3. **API Mocking Strategies**
   - Use `jest.mock('node-fetch')` or fetch mock
   - Create mock response factories
   - Test both success and error responses
   - Verify request headers and body

4. **Storage Testing**
   - Mock Office.context.roamingSettings
   - Mock localStorage for fallback
   - Test synchronous and asynchronous operations
   - Test storage limitations and quota errors

5. **Performance Considerations**
   - Run tests in parallel (Jest default)
   - Use test.only() for focused testing during development
   - Skip slow integration tests in watch mode
   - Use coverage cache for faster subsequent runs

6. **CI/CD Integration**
   - Run tests on every commit (pre-commit hook)
   - Run tests on pull requests (GitHub Actions)
   - Block merges if tests fail
   - Generate coverage reports for PR review
   - Archive coverage reports as artifacts

## Definition of Done

- [ ] Jest configured with TypeScript support
- [ ] Test setup file created (setupTests.ts)
- [ ] Office.js and MSAL mocked globally
- [ ] Unit tests written for all services (auth, singlecase, cases, graphMail, client)
- [ ] Unit tests written for all utilities (storage, cache, suggestionEngine)
- [ ] Unit tests written for hooks with business logic
- [ ] Unit tests written for command handlers
- [ ] Integration tests for filing workflow
- [ ] Integration tests for authentication flow
- [ ] Test data factories created
- [ ] Code coverage at 80%+ for all modules
- [ ] Coverage report generated (HTML, LCOV)
- [ ] Tests pass on `npm test`
- [ ] Tests integrated into CI/CD pipeline
- [ ] Coverage thresholds enforced (build fails if below 80%)
- [ ] Test documentation added to README
- [ ] Mock strategy documented
- [ ] Test commands added to package.json
